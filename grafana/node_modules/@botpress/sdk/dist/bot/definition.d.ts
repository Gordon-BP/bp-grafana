import { IntegrationPackage, PluginPackage } from '../package';
import { SchemaDefinition } from '../schema';
import { ValueOf } from '../utils/type-utils';
import z, { ZuiObjectSchema } from '../zui';
type BaseConfig = ZuiObjectSchema;
type BaseStates = Record<string, ZuiObjectSchema>;
type BaseEvents = Record<string, ZuiObjectSchema>;
type BaseActions = Record<string, ZuiObjectSchema>;
export type TagDefinition = {
    title?: string;
    description?: string;
};
export type StateType = 'conversation' | 'user' | 'bot';
export type StateDefinition<TState extends BaseStates[string] = BaseStates[string]> = SchemaDefinition<TState> & {
    type: StateType;
    expiry?: number;
};
export type RecurringEventDefinition<TEvents extends BaseEvents = BaseEvents> = {
    [K in keyof TEvents]: {
        type: K;
        payload: z.infer<TEvents[K]>;
        schedule: {
            cron: string;
        };
    };
}[keyof TEvents];
export type EventDefinition<TEvent extends BaseEvents[string] = BaseEvents[string]> = SchemaDefinition<TEvent>;
export type ConfigurationDefinition<TConfig extends BaseConfig = BaseConfig> = SchemaDefinition<TConfig>;
export type UserDefinition = {
    tags?: Record<string, TagDefinition>;
};
export type ConversationDefinition = {
    tags?: Record<string, TagDefinition>;
};
export type MessageDefinition = {
    tags?: Record<string, TagDefinition>;
};
export type ActionDefinition<TAction extends BaseActions[string] = BaseActions[string]> = {
    title?: string;
    description?: string;
    input: SchemaDefinition<TAction>;
    output: SchemaDefinition<ZuiObjectSchema>;
};
export type IntegrationConfigInstance<I extends IntegrationPackage = IntegrationPackage> = {
    enabled: boolean;
} & ({
    configurationType?: null;
    configuration: z.infer<NonNullable<I['definition']['configuration']>['schema']>;
} | ValueOf<{
    [K in keyof NonNullable<I['definition']['configurations']>]: {
        configurationType: K;
        configuration: z.infer<NonNullable<I['definition']['configurations']>[K]['schema']>;
    };
}>);
export type PluginConfigInstance<P extends PluginPackage = PluginPackage> = {
    configuration: z.infer<NonNullable<P['definition']['configuration']>['schema']>;
    interfaces: {
        [I in keyof NonNullable<P['definition']['interfaces']>]: {
            name: string;
            version: string;
        };
    };
};
export type IntegrationInstance = IntegrationPackage & IntegrationConfigInstance;
export type PluginInstance = PluginPackage & PluginConfigInstance;
export type BotDefinitionProps<TStates extends BaseStates = BaseStates, TEvents extends BaseEvents = BaseEvents, TActions extends BaseActions = BaseActions> = {
    integrations?: {
        [K: string]: IntegrationInstance;
    };
    plugins?: {
        [K: string]: PluginInstance;
    };
    user?: UserDefinition;
    conversation?: ConversationDefinition;
    message?: MessageDefinition;
    states?: {
        [K in keyof TStates]: StateDefinition<TStates[K]>;
    };
    configuration?: ConfigurationDefinition;
    events?: {
        [K in keyof TEvents]: EventDefinition<TEvents[K]>;
    };
    recurringEvents?: Record<string, RecurringEventDefinition<TEvents>>;
    actions?: {
        [K in keyof TActions]: ActionDefinition<TActions[K]>;
    };
};
export declare class BotDefinition<TStates extends BaseStates = BaseStates, TEvents extends BaseEvents = BaseEvents, TActions extends BaseActions = BaseActions> {
    readonly props: BotDefinitionProps<TStates, TEvents, TActions>;
    readonly integrations: this['props']['integrations'];
    readonly plugins: this['props']['plugins'];
    readonly user: this['props']['user'];
    readonly conversation: this['props']['conversation'];
    readonly message: this['props']['message'];
    readonly states: this['props']['states'];
    readonly configuration: this['props']['configuration'];
    readonly events: this['props']['events'];
    readonly recurringEvents: this['props']['recurringEvents'];
    readonly actions: this['props']['actions'];
    constructor(props: BotDefinitionProps<TStates, TEvents, TActions>);
    addIntegration<I extends IntegrationPackage>(integrationPkg: I, config: IntegrationConfigInstance<I>): this;
    addPlugin<P extends PluginPackage>(pluginPkg: P, config: PluginConfigInstance<P>): this;
    private _mergeUser;
    private _mergeConversation;
    private _mergeMessage;
    private _mergeStates;
    private _mergeEvents;
    private _mergeRecurringEvents;
    private _mergeActions;
}
export {};
