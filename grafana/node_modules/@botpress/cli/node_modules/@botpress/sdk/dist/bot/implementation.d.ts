import type { Server } from 'node:http';
import { BasePlugin, PluginImplementation } from '../plugin';
import { MessageHandlersMap, MessageHandlers, EventHandlersMap, EventHandlers, StateExpiredHandlersMap, StateExpiredHandlers, HookHandlersMap, HookData, HookHandlers, ActionHandlers, BotHandlers, UnimplementedActionHandlers } from './server';
import { BaseBot } from './types';
export type BotImplementationProps<TBot extends BaseBot = BaseBot, TPlugins extends Record<string, BasePlugin> = {}> = {
    actions: UnimplementedActionHandlers<TBot, TPlugins>;
    plugins: {
        [K in keyof TPlugins]: PluginImplementation<TPlugins[K]>;
    };
};
export declare class BotImplementation<TBot extends BaseBot = BaseBot, TPlugins extends Record<string, BasePlugin> = {}> implements BotHandlers<TBot> {
    readonly props: BotImplementationProps<TBot, TPlugins>;
    readonly actionHandlers: ActionHandlers<TBot>;
    readonly messageHandlers: MessageHandlersMap<TBot>;
    readonly eventHandlers: EventHandlersMap<TBot>;
    readonly stateExpiredHandlers: StateExpiredHandlersMap<TBot>;
    readonly hookHandlers: HookHandlersMap<TBot>;
    /**
     * alias for actionHandlers
     */
    get actions(): ActionHandlers<TBot>;
    constructor(props: BotImplementationProps<TBot, TPlugins>);
    readonly on: {
        message: <T extends keyof MessageHandlersMap<TBot>>(type: T, handler: MessageHandlers<TBot>[T]) => void;
        event: <T extends keyof EventHandlersMap<TBot>>(type: T, handler: EventHandlers<TBot>[T]) => void;
        stateExpired: <T extends keyof StateExpiredHandlersMap<TBot>>(type: T, handler: StateExpiredHandlers<TBot>[T]) => void;
        beforeIncomingEvent: <T extends keyof HookData<TBot>["before_incoming_event"]>(type: T, handler: HookHandlers<TBot>["before_incoming_event"][T]) => void;
        beforeIncomingMessage: <T extends keyof HookData<TBot>["before_incoming_message"]>(type: T, handler: HookHandlers<TBot>["before_incoming_message"][T]) => void;
        beforeOutgoingMessage: <T extends keyof HookData<TBot>["before_outgoing_message"]>(type: T, handler: HookHandlers<TBot>["before_outgoing_message"][T]) => void;
        beforeOutgoingCallAction: <T extends keyof HookData<TBot>["before_outgoing_call_action"]>(type: T, handler: HookHandlers<TBot>["before_outgoing_call_action"][T]) => void;
        afterIncomingEvent: <T extends keyof HookData<TBot>["after_incoming_event"]>(type: T, handler: HookHandlers<TBot>["after_incoming_event"][T]) => void;
        afterIncomingMessage: <T extends keyof HookData<TBot>["after_incoming_message"]>(type: T, handler: HookHandlers<TBot>["after_incoming_message"][T]) => void;
        afterOutgoingMessage: <T extends keyof HookData<TBot>["after_outgoing_message"]>(type: T, handler: HookHandlers<TBot>["after_outgoing_message"][T]) => void;
        afterOutgoingCallAction: <T extends keyof HookData<TBot>["after_outgoing_call_action"]>(type: T, handler: HookHandlers<TBot>["after_outgoing_call_action"][T]) => void;
    };
    private readonly _use;
    readonly handler: (req: import("../serve").Request) => Promise<import("../serve").Response | void>;
    readonly start: (port?: number) => Promise<Server>;
}
