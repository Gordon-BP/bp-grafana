{
  "version": 3,
  "sources": ["../../src/command-implementations/integration-commands.ts"],
  "sourcesContent": ["import chalk from 'chalk'\nimport _ from 'lodash'\nimport { ApiClient, Integration } from 'src/api/client'\nimport type commandDefinitions from '../command-definitions'\nimport * as errors from '../errors'\nimport { NamePackageRef, parsePackageRef } from '../package-ref'\nimport { GlobalCommand } from './global-command'\n\nexport type GetIntegrationCommandDefinition = typeof commandDefinitions.integrations.subcommands.get\nexport class GetIntegrationCommand extends GlobalCommand<GetIntegrationCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n    const parsedRef = parsePackageRef(this.argv.integrationRef)\n    if (!parsedRef) {\n      throw new errors.InvalidPackageReferenceError(this.argv.integrationRef)\n    }\n    if (parsedRef.type === 'path') {\n      throw new errors.BotpressCLIError('Cannot get local integration')\n    }\n\n    try {\n      const integration = await api.findIntegration(parsedRef)\n      if (integration) {\n        this.logger.success(`Integration ${chalk.bold(this.argv.integrationRef)}:`)\n        this.logger.json(integration)\n        return\n      }\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not get integration ${this.argv.integrationRef}`)\n    }\n\n    throw new errors.BotpressCLIError(`Integration ${this.argv.integrationRef} not found`)\n  }\n}\n\nexport type ListIntegrationsCommandDefinition = typeof commandDefinitions.integrations.subcommands.list\nexport class ListIntegrationsCommand extends GlobalCommand<ListIntegrationsCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n\n    const { dev, name, versionNumber: version } = this.argv\n\n    const privateLister = (req: { nextToken?: string }) =>\n      api.client.listIntegrations({ nextToken: req.nextToken, dev, name, version })\n\n    const dummyLister: typeof privateLister = async () => ({ integrations: [], meta: {} })\n    const publicLister = dev\n      ? dummyLister\n      : (req: { nextToken?: string }) => api.client.listPublicIntegrations({ nextToken: req.nextToken, name, version })\n\n    try {\n      const privateIntegrations = await api.listAllPages(privateLister, (r) => r.integrations)\n      const publicIntegrations = await api.listAllPages(publicLister, (r) => r.integrations)\n      const integrations = _.uniqBy([...privateIntegrations, ...publicIntegrations], (i) => i.id)\n\n      this.logger.success('Integrations:')\n      this.logger.json(integrations)\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not list integrations')\n    }\n  }\n}\n\nexport type DeleteIntegrationCommandDefinition = typeof commandDefinitions.integrations.subcommands.delete\nexport class DeleteIntegrationCommand extends GlobalCommand<DeleteIntegrationCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n    const parsedRef = parsePackageRef(this.argv.integrationRef)\n    if (!parsedRef) {\n      throw new errors.InvalidPackageReferenceError(this.argv.integrationRef)\n    }\n    if (parsedRef.type === 'path') {\n      throw new errors.BotpressCLIError('Cannot delete local integration')\n    }\n\n    let integrationId: string | undefined\n    if (parsedRef.type === 'id') {\n      integrationId = parsedRef.id\n    } else {\n      const integration = await this._findIntegration(api, parsedRef)\n      integrationId = integration.id\n    }\n\n    try {\n      await api.client.deleteIntegration({ id: integrationId })\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not delete integration ${this.argv.integrationRef}`)\n    }\n\n    this.logger.success(`Integration ${chalk.bold(this.argv.integrationRef)} deleted`)\n    return\n  }\n\n  private _findIntegration = async (api: ApiClient, parsedRef: NamePackageRef) => {\n    let integration: Integration | undefined\n\n    try {\n      integration = await api.findPrivateIntegration(parsedRef)\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not get integration ${this.argv.integrationRef}`)\n    }\n\n    if (!integration) {\n      const publicIntegration = await api.findPublicIntegration(parsedRef)\n      if (publicIntegration) {\n        throw new errors.BotpressCLIError(`Integration ${this.argv.integrationRef} does not belong to your workspace`)\n      }\n\n      throw new errors.BotpressCLIError(`Integration ${this.argv.integrationRef} not found`)\n    }\n\n    return integration\n  }\n}\n"],
  "mappings": "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",
  "names": ["chalk", "_"]
}
