{
  "version": 3,
  "sources": ["../../src/command-implementations/add-command.ts"],
  "sourcesContent": ["import * as sdk from '@botpress/sdk'\nimport * as fslib from 'fs'\nimport * as pathlib from 'path'\nimport { ApiClient } from '../api'\nimport * as codegen from '../code-generation'\nimport type commandDefinitions from '../command-definitions'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport * as pkgRef from '../package-ref'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\nimport { ProjectCache, ProjectCommand, ProjectCommandDefinition, ProjectDefinition } from './project-command'\n\ntype InstallablePackage =\n  | {\n      type: 'integration'\n      pkg: codegen.IntegrationInstallablePackage\n    }\n  | {\n      type: 'interface'\n      pkg: codegen.InterfaceInstallablePackage\n    }\n  | {\n      type: 'plugin'\n      pkg: codegen.PluginInstallablePackage\n    }\n\nexport type AddCommandDefinition = typeof commandDefinitions.add\nexport class AddCommand extends GlobalCommand<AddCommandDefinition> {\n  public async run(): Promise<void> {\n    const ref = this._parseArgvRef()\n    if (ref) {\n      return await this._addSinglePackage(ref)\n    }\n\n    const pkgJson = await utils.pkgJson.readPackageJson(this.argv.installPath)\n    if (!pkgJson) {\n      this.logger.warn('No package.json found in the install path')\n      return\n    }\n\n    const { bpDependencies } = pkgJson\n    if (!bpDependencies) {\n      this.logger.log('No bp dependencies found in package.json')\n      return\n    }\n\n    const bpDependenciesSchema = sdk.z.record(sdk.z.string())\n    const parseResults = bpDependenciesSchema.safeParse(bpDependencies)\n    if (!parseResults.success) {\n      throw new errors.BotpressCLIError('Invalid bpDependencies found in package.json')\n    }\n\n    for (const [pkgAlias, pkgRefStr] of Object.entries(parseResults.data)) {\n      const parsed = pkgRef.parsePackageRef(pkgRefStr)\n      if (!parsed) {\n        throw new errors.InvalidPackageReferenceError(pkgRefStr)\n      }\n\n      await this._addSinglePackage({ ...parsed, alias: pkgAlias })\n    }\n  }\n\n  private _parseArgvRef = (): pkgRef.PackageRef | undefined => {\n    if (!this.argv.packageRef) {\n      return\n    }\n\n    const parsed = pkgRef.parsePackageRef(this.argv.packageRef)\n    if (!parsed) {\n      throw new errors.InvalidPackageReferenceError(this.argv.packageRef)\n    }\n\n    if (parsed.type !== 'name') {\n      return parsed\n    }\n\n    const argvPkgType = this.argv.packageType\n    if (!argvPkgType) {\n      return parsed\n    }\n\n    const ref = { ...parsed, pkg: argvPkgType }\n\n    const strRef = pkgRef.formatPackageRef(ref)\n    this.logger.warn(`argument --packageType is deprecated; please use the package reference format \"${strRef}\"`)\n\n    return ref\n  }\n\n  private async _addSinglePackage(ref: pkgRef.PackageRef & { alias?: string }): Promise<void> {\n    const targetPackage = ref.type === 'path' ? await this._findLocalPackage(ref) : await this._findRemotePackage(ref)\n\n    if (!targetPackage) {\n      const strRef = pkgRef.formatPackageRef(ref)\n      throw new errors.BotpressCLIError(`Could not find package \"${strRef}\"`)\n    }\n\n    const packageName = ref.alias ?? targetPackage.pkg.name\n    const baseInstallPath = utils.path.absoluteFrom(utils.path.cwd(), this.argv.installPath)\n    const packageDirName = utils.casing.to.kebabCase(packageName)\n    const installPath = utils.path.join(baseInstallPath, consts.installDirName, packageDirName)\n\n    const alreadyInstalled = fslib.existsSync(installPath)\n    if (alreadyInstalled) {\n      this.logger.warn(`Package with name \"${packageName}\" already installed.`)\n      const res = await this.prompt.confirm('Do you want to overwrite the existing package?')\n      if (!res) {\n        this.logger.log('Aborted')\n        return\n      }\n\n      await this._uninstall(installPath)\n    }\n\n    let files: codegen.File[]\n    if (targetPackage.type === 'integration') {\n      files = await codegen.generateIntegrationPackage(targetPackage.pkg)\n    } else if (targetPackage.type === 'interface') {\n      files = await codegen.generateInterfacePackage(targetPackage.pkg)\n    } else if (targetPackage.type === 'plugin') {\n      files = await codegen.generatePluginPackage(targetPackage.pkg)\n    } else {\n      type _assertion = utils.types.AssertNever<typeof targetPackage>\n      throw new errors.BotpressCLIError('Invalid package type')\n    }\n\n    await this._install(installPath, files)\n  }\n\n  private async _findRemotePackage(ref: pkgRef.ApiPackageRef): Promise<InstallablePackage | undefined> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n    if (this._pkgCouldBe(ref, 'integration')) {\n      const integration = await api.findIntegration(ref)\n      if (integration) {\n        const { name, version } = integration\n        return { type: 'integration', pkg: { source: 'remote', integration, name, version } }\n      }\n    }\n    if (this._pkgCouldBe(ref, 'interface')) {\n      const intrface = await api.findPublicInterface(ref)\n      if (intrface) {\n        const { name, version } = intrface\n        return { type: 'interface', pkg: { source: 'remote', interface: intrface, name, version } }\n      }\n    }\n    if (this._pkgCouldBe(ref, 'plugin')) {\n      const plugin = await api.findPublicPlugin(ref)\n      if (plugin) {\n        const { name, version } = plugin\n        return { type: 'plugin', pkg: { source: 'remote', plugin, name, version } }\n      }\n    }\n    return\n  }\n\n  private async _findLocalPackage(ref: pkgRef.LocalPackageRef): Promise<InstallablePackage | undefined> {\n    const absPath = utils.path.absoluteFrom(utils.path.cwd(), ref.path)\n    const {\n      definition: projectDefinition,\n      implementation: projectImplementation,\n      devId: projectDevId,\n    } = await this._readProject(absPath)\n\n    if (projectDefinition?.type === 'integration') {\n      const { name, version } = projectDefinition.definition\n      let devId: string | undefined\n      if (this.argv.useDev && projectDevId) {\n        this.logger.warn(`Installing integration \"${name}\" with dev version \"${projectDevId}\"`)\n        devId = projectDevId\n      }\n      return {\n        type: 'integration',\n        pkg: { source: 'local', path: absPath, devId, name, version },\n      }\n    }\n\n    if (projectDefinition?.type === 'interface') {\n      const { name, version } = projectDefinition.definition\n      return {\n        type: 'interface',\n        pkg: { source: 'local', path: absPath, name, version },\n      }\n    }\n\n    if (projectDefinition?.type === 'plugin') {\n      if (!projectImplementation) {\n        throw new errors.BotpressCLIError(\n          'Plugin implementation not found; Please build the plugin project before installing'\n        )\n      }\n\n      const { name, version } = projectDefinition.definition\n      return {\n        type: 'plugin',\n        pkg: {\n          source: 'local',\n          path: absPath,\n          implementationCode: projectImplementation,\n          name,\n          version,\n        },\n      }\n    }\n\n    if (projectDefinition?.type === 'bot') {\n      throw new errors.BotpressCLIError('Cannot install a bot as a package')\n    }\n    return\n  }\n\n  private async _install(installPath: utils.path.AbsolutePath, files: codegen.File[]): Promise<void> {\n    const line = this.logger.line()\n    line.started(`Installing ${files.length} files to \"${installPath}\"`)\n    try {\n      for (const file of files) {\n        const filePath = utils.path.absoluteFrom(installPath, file.path)\n        const dirPath = pathlib.dirname(filePath)\n        await fslib.promises.mkdir(dirPath, { recursive: true })\n        await fslib.promises.writeFile(filePath, file.content)\n      }\n      line.success(`Installed ${files.length} files to \"${installPath}\"`)\n    } finally {\n      line.commit()\n    }\n  }\n\n  private async _uninstall(installPath: utils.path.AbsolutePath): Promise<void> {\n    await fslib.promises.rm(installPath, { recursive: true })\n  }\n\n  private async _readProject(workDir: utils.path.AbsolutePath): Promise<{\n    definition?: ProjectDefinition\n    implementation?: string\n    devId?: string\n  }> {\n    // this is a hack to avoid refactoring the project command class\n    class AnyProjectCommand extends ProjectCommand<ProjectCommandDefinition> {\n      public async run(): Promise<void> {\n        throw new errors.BotpressCLIError('Not implemented')\n      }\n\n      public async readProjectDefinitionFromFS(): Promise<ProjectDefinition> {\n        return super.readProjectDefinitionFromFS()\n      }\n\n      public get projectCache(): utils.cache.FSKeyValueCache<ProjectCache> {\n        return super.projectCache\n      }\n    }\n\n    const cmd = new AnyProjectCommand(ApiClient, this.prompt, this.logger, {\n      ...this.argv,\n      workDir,\n    })\n\n    const definition = await cmd.readProjectDefinitionFromFS().catch((thrown) => {\n      if (thrown instanceof errors.ProjectDefinitionNotFoundError) {\n        return undefined\n      }\n      throw thrown\n    })\n\n    const devId = await cmd.projectCache.get('devId')\n\n    const implementationAbsPath = utils.path.join(workDir, consts.fromWorkDir.outFile)\n    if (!fslib.existsSync(implementationAbsPath)) {\n      return { definition, devId }\n    }\n\n    const implementation = await fslib.promises.readFile(implementationAbsPath, 'utf8')\n    return { definition, implementation, devId }\n  }\n\n  private _pkgCouldBe = (ref: pkgRef.ApiPackageRef, pkgType: InstallablePackage['type']) => {\n    if (ref.type === 'id') {\n      // TODO: use ULID prefixes to determine the type of the package\n      return true\n    }\n    if (!ref.pkg) {\n      return true // ref does not specify the package type\n    }\n    return ref.pkg === pkgType\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
