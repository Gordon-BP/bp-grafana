{
  "version": 3,
  "sources": ["../../../src/code-generation/interface-package/index.ts"],
  "sourcesContent": ["import * as utils from '../../utils'\nimport * as consts from '../consts'\nimport * as gen from '../generators'\nimport * as types from '../typings'\nimport { InterfacePackageDefinitionModule } from './interface-package-definition'\n\nconst generateInterfacePackageModule = (definitionImport: string, pkg: types.InterfaceInstallablePackage): string => {\n  const id = pkg.source === 'remote' ? pkg.interface.id : undefined\n  const uri = pkg.source === 'local' ? utils.path.win32.escapeBackslashes(pkg.path) : undefined\n\n  const tsId = gen.primitiveToTypescriptValue(id)\n  const tsUri = gen.primitiveToTypescriptValue(uri)\n  const tsName = gen.primitiveToTypescriptValue(pkg.name)\n  const tsVersion = gen.primitiveToTypescriptValue(pkg.version)\n  return [\n    consts.GENERATED_HEADER,\n    'import * as sdk from \"@botpress/sdk\"',\n    '',\n    `import definition from \"${utils.path.win32.escapeBackslashes(definitionImport)}\"`,\n    '',\n    'export default {',\n    '  type: \"interface\",',\n    `  id: ${tsId},`,\n    `  uri: ${tsUri},`,\n    `  name: ${tsName},`,\n    `  version: ${tsVersion},`,\n    '  definition,',\n    '} satisfies sdk.InterfacePackage',\n  ].join('\\n')\n}\n\nconst generateInterfacePackageFromRemote = async (\n  pkg: Extract<types.InterfaceInstallablePackage, { source: 'remote' }>\n): Promise<types.File[]> => {\n  const definitionDir = 'definition'\n  const definitionModule = new InterfacePackageDefinitionModule(pkg.interface)\n  definitionModule.unshift(definitionDir)\n\n  const definitionFiles = await definitionModule.flatten()\n  return [\n    ...definitionFiles,\n    {\n      path: consts.INDEX_FILE,\n      content: generateInterfacePackageModule(`./${definitionDir}`, pkg),\n    },\n  ]\n}\n\nconst generateInterfacePackageFromLocal = async (\n  pkg: Extract<types.InterfaceInstallablePackage, { source: 'local' }>\n): Promise<types.File[]> => {\n  let definitionImport: string = utils.path.join(pkg.path, consts.fromWorkDir.interfaceDefinition)\n  definitionImport = utils.path.rmExtension(definitionImport)\n  return [\n    {\n      path: consts.INDEX_FILE,\n      content: generateInterfacePackageModule(definitionImport, pkg),\n    },\n  ]\n}\n\nexport const generateInterfacePackage = async (pkg: types.InterfaceInstallablePackage): Promise<types.File[]> => {\n  if (pkg.source === 'remote') {\n    return generateInterfacePackageFromRemote(pkg)\n  }\n  return generateInterfacePackageFromLocal(pkg)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAuB;AACvB,aAAwB;AACxB,UAAqB;AAErB,0CAAiD;AAEjD,MAAM,iCAAiC,CAAC,kBAA0B,QAAmD;AACnH,QAAM,KAAK,IAAI,WAAW,WAAW,IAAI,UAAU,KAAK;AACxD,QAAM,MAAM,IAAI,WAAW,UAAU,MAAM,KAAK,MAAM,kBAAkB,IAAI,IAAI,IAAI;AAEpF,QAAM,OAAO,IAAI,2BAA2B,EAAE;AAC9C,QAAM,QAAQ,IAAI,2BAA2B,GAAG;AAChD,QAAM,SAAS,IAAI,2BAA2B,IAAI,IAAI;AACtD,QAAM,YAAY,IAAI,2BAA2B,IAAI,OAAO;AAC5D,SAAO;AAAA,IACL,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,2BAA2B,MAAM,KAAK,MAAM,kBAAkB,gBAAgB;AAAA,IAC9E;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,UAAU;AAAA,IACV,WAAW;AAAA,IACX,cAAc;AAAA,IACd;AAAA,IACA;AAAA,EACF,EAAE,KAAK,IAAI;AACb;AAEA,MAAM,qCAAqC,OACzC,QAC0B;AAC1B,QAAM,gBAAgB;AACtB,QAAM,mBAAmB,IAAI,qEAAiC,IAAI,SAAS;AAC3E,mBAAiB,QAAQ,aAAa;AAEtC,QAAM,kBAAkB,MAAM,iBAAiB,QAAQ;AACvD,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,MACE,MAAM,OAAO;AAAA,MACb,SAAS,+BAA+B,KAAK,iBAAiB,GAAG;AAAA,IACnE;AAAA,EACF;AACF;AAEA,MAAM,oCAAoC,OACxC,QAC0B;AAC1B,MAAI,mBAA2B,MAAM,KAAK,KAAK,IAAI,MAAM,OAAO,YAAY,mBAAmB;AAC/F,qBAAmB,MAAM,KAAK,YAAY,gBAAgB;AAC1D,SAAO;AAAA,IACL;AAAA,MACE,MAAM,OAAO;AAAA,MACb,SAAS,+BAA+B,kBAAkB,GAAG;AAAA,IAC/D;AAAA,EACF;AACF;AAEO,MAAM,2BAA2B,OAAO,QAAkE;AAC/G,MAAI,IAAI,WAAW,UAAU;AAC3B,WAAO,mCAAmC,GAAG;AAAA,EAC/C;AACA,SAAO,kCAAkC,GAAG;AAC9C;",
  "names": []
}
