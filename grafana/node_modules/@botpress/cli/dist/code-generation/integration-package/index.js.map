{
  "version": 3,
  "sources": ["../../../src/code-generation/integration-package/index.ts"],
  "sourcesContent": ["import * as utils from '../../utils'\nimport * as consts from '../consts'\nimport * as gen from '../generators'\nimport * as types from '../typings'\nimport { IntegrationPackageDefinitionModule } from './integration-package-definition'\n\nconst generateIntegrationPackageModule = (\n  definitionImport: string,\n  pkg: types.IntegrationInstallablePackage\n): string => {\n  const id = pkg.source === 'remote' ? pkg.integration.id : pkg.devId\n  const uri = pkg.source === 'local' ? utils.path.win32.escapeBackslashes(pkg.path) : undefined\n\n  const tsId = gen.primitiveToTypescriptValue(id)\n  const tsUri = gen.primitiveToTypescriptValue(uri)\n  const tsName = gen.primitiveToTypescriptValue(pkg.name)\n  const tsVersion = gen.primitiveToTypescriptValue(pkg.version)\n\n  return [\n    consts.GENERATED_HEADER,\n    'import * as sdk from \"@botpress/sdk\"',\n    '',\n    `import definition from \"${utils.path.win32.escapeBackslashes(definitionImport)}\"`,\n    '',\n    'export default {',\n    '  type: \"integration\",',\n    `  id: ${tsId},`,\n    `  uri: ${tsUri},`,\n    `  name: ${tsName},`,\n    `  version: ${tsVersion},`,\n    '  definition,',\n    '} satisfies sdk.IntegrationPackage',\n  ].join('\\n')\n}\n\nconst generateIntegrationPackageFromRemote = async (\n  pkg: Extract<types.IntegrationInstallablePackage, { source: 'remote' }>\n): Promise<types.File[]> => {\n  const definitionDir = 'definition'\n  const definitionModule = new IntegrationPackageDefinitionModule(pkg.integration)\n  definitionModule.unshift(definitionDir)\n\n  const definitionFiles = await definitionModule.flatten()\n  return [\n    ...definitionFiles,\n    {\n      path: consts.INDEX_FILE,\n      content: generateIntegrationPackageModule(`./${definitionDir}`, pkg),\n    },\n  ]\n}\n\nconst generateIntegrationPackageFromLocal = async (\n  pkg: Extract<types.IntegrationInstallablePackage, { source: 'local' }>\n): Promise<types.File[]> => {\n  let definitionImport: string = utils.path.join(pkg.path, consts.fromWorkDir.integrationDefinition)\n  definitionImport = utils.path.rmExtension(definitionImport)\n  return [\n    {\n      path: consts.INDEX_FILE,\n      content: generateIntegrationPackageModule(definitionImport, pkg),\n    },\n  ]\n}\n\nexport const generateIntegrationPackage = async (pkg: types.IntegrationInstallablePackage): Promise<types.File[]> => {\n  if (pkg.source === 'remote') {\n    return generateIntegrationPackageFromRemote(pkg)\n  }\n  return generateIntegrationPackageFromLocal(pkg)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAuB;AACvB,aAAwB;AACxB,UAAqB;AAErB,4CAAmD;AAEnD,MAAM,mCAAmC,CACvC,kBACA,QACW;AACX,QAAM,KAAK,IAAI,WAAW,WAAW,IAAI,YAAY,KAAK,IAAI;AAC9D,QAAM,MAAM,IAAI,WAAW,UAAU,MAAM,KAAK,MAAM,kBAAkB,IAAI,IAAI,IAAI;AAEpF,QAAM,OAAO,IAAI,2BAA2B,EAAE;AAC9C,QAAM,QAAQ,IAAI,2BAA2B,GAAG;AAChD,QAAM,SAAS,IAAI,2BAA2B,IAAI,IAAI;AACtD,QAAM,YAAY,IAAI,2BAA2B,IAAI,OAAO;AAE5D,SAAO;AAAA,IACL,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,2BAA2B,MAAM,KAAK,MAAM,kBAAkB,gBAAgB;AAAA,IAC9E;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,UAAU;AAAA,IACV,WAAW;AAAA,IACX,cAAc;AAAA,IACd;AAAA,IACA;AAAA,EACF,EAAE,KAAK,IAAI;AACb;AAEA,MAAM,uCAAuC,OAC3C,QAC0B;AAC1B,QAAM,gBAAgB;AACtB,QAAM,mBAAmB,IAAI,yEAAmC,IAAI,WAAW;AAC/E,mBAAiB,QAAQ,aAAa;AAEtC,QAAM,kBAAkB,MAAM,iBAAiB,QAAQ;AACvD,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,MACE,MAAM,OAAO;AAAA,MACb,SAAS,iCAAiC,KAAK,iBAAiB,GAAG;AAAA,IACrE;AAAA,EACF;AACF;AAEA,MAAM,sCAAsC,OAC1C,QAC0B;AAC1B,MAAI,mBAA2B,MAAM,KAAK,KAAK,IAAI,MAAM,OAAO,YAAY,qBAAqB;AACjG,qBAAmB,MAAM,KAAK,YAAY,gBAAgB;AAC1D,SAAO;AAAA,IACL;AAAA,MACE,MAAM,OAAO;AAAA,MACb,SAAS,iCAAiC,kBAAkB,GAAG;AAAA,IACjE;AAAA,EACF;AACF;AAEO,MAAM,6BAA6B,OAAO,QAAoE;AACnH,MAAI,IAAI,WAAW,UAAU;AAC3B,WAAO,qCAAqC,GAAG;AAAA,EACjD;AACA,SAAO,oCAAoC,GAAG;AAChD;",
  "names": []
}
