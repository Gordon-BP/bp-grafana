{
  "version": 3,
  "sources": ["../../src/sdk/resolve-integration-interfaces.ts"],
  "sourcesContent": ["import * as sdk from '@botpress/sdk'\nimport _ from 'lodash'\nimport * as utils from '../utils'\n\ntype InterfaceExtension = NonNullable<sdk.IntegrationDefinition['interfaces']>[string]\ntype ResolvedInterface = {\n  actions: Record<string, sdk.ActionDefinition>\n  events: Record<string, sdk.EventDefinition>\n  channels: Record<string, sdk.ChannelDefinition>\n}\ntype InterfaceImplStatement = {\n  id?: string\n  name: string\n  version: string\n  entities: Record<string, { name: string }>\n  actions: Record<string, { name: string }>\n  events: Record<string, { name: string }>\n  channels: Record<string, { name: string }>\n}\n\ntype ZodObjectSchema = sdk.z.ZodObject | sdk.z.ZodRecord\n\nexport const resolveInterfaces = (integration: sdk.IntegrationDefinition): sdk.IntegrationDefinition => {\n  const self = integration as utils.types.Writable<sdk.IntegrationDefinition>\n  if (!self.interfaces) {\n    return integration\n  }\n\n  for (const intrface of Object.values(self.interfaces)) {\n    const { resolved } = _resolveInterface(intrface)\n\n    /**\n     * If an action is defined both in the integration and the interface; we merge both.\n     * This allows setting more specific properties in the integration, while staying compatible with the interface.\n     * Same goes for channels and events.\n     */\n\n    self.actions = utils.records.mergeRecords(self.actions ?? {}, resolved.actions, _mergeActions)\n    self.channels = utils.records.mergeRecords(self.channels ?? {}, resolved.channels, _mergeChannels)\n    self.events = utils.records.mergeRecords(self.events ?? {}, resolved.events, _mergeEvents)\n  }\n\n  return self\n}\n\nexport const getImplementationStatements = (\n  integration: sdk.IntegrationDefinition\n): Record<string, InterfaceImplStatement> => {\n  const self = integration as utils.types.Writable<sdk.IntegrationDefinition>\n  if (!self.interfaces) {\n    return {}\n  }\n\n  const statements: Record<string, InterfaceImplStatement> = {}\n  for (const [interfaceKey, intrface] of Object.entries(self.interfaces)) {\n    const { statement } = _resolveInterface(intrface)\n    statements[interfaceKey] = statement\n  }\n\n  return statements\n}\n\nconst _mergeActions = (a: sdk.ActionDefinition, b: sdk.ActionDefinition): sdk.ActionDefinition => {\n  return {\n    ...a,\n    ...b,\n    input: {\n      schema: _mergeObjectSchemas(a.input.schema, b.input.schema),\n    },\n    output: {\n      schema: _mergeObjectSchemas(a.input.schema, b.output.schema),\n    },\n  }\n}\n\nconst _mergeEvents = (a: sdk.EventDefinition, b: sdk.EventDefinition): sdk.EventDefinition => {\n  return {\n    ...a,\n    ...b,\n    schema: _mergeObjectSchemas(a.schema, b.schema),\n  }\n}\n\nconst _mergeChannels = (a: sdk.ChannelDefinition, b: sdk.ChannelDefinition): sdk.ChannelDefinition => {\n  const messages = utils.records.mergeRecords(a.messages, b.messages, _mergeMessage)\n  return {\n    ...a,\n    ...b,\n    messages,\n  }\n}\n\nconst _mergeMessage = (a: sdk.MessageDefinition, b: sdk.MessageDefinition): sdk.MessageDefinition => {\n  return {\n    schema: _mergeObjectSchemas(a.schema, b.schema),\n  }\n}\n\nconst _resolveInterface = (\n  intrface: InterfaceExtension\n): { resolved: ResolvedInterface; statement: InterfaceImplStatement } => {\n  const { id } = intrface\n  const { name, version } = intrface\n\n  const resolved: ResolvedInterface = { actions: {}, events: {}, channels: {} }\n  const statement: InterfaceImplStatement = {\n    id,\n    name,\n    version,\n    entities: _.mapValues(intrface.entities, (entity) => ({ name: entity.name })), // { item: { name: 'issue' } },\n    actions: {},\n    events: {},\n    channels: {},\n  }\n\n  const entitySchemas = _.mapValues(intrface.entities, (entity) => entity.schema)\n\n  // dereference actions\n  for (const [actionName, action] of Object.entries(intrface.definition.actions ?? {})) {\n    const resolvedInputSchema = action.input.schema.dereference(entitySchemas) as sdk.z.AnyZodObject\n    const resolvedOutputSchema = action.output.schema.dereference(entitySchemas) as sdk.z.AnyZodObject\n\n    const newActionName = _rename(intrface, actionName)\n    resolved.actions[newActionName] = {\n      ...action,\n      input: { schema: resolvedInputSchema },\n      output: { schema: resolvedOutputSchema },\n    }\n    statement.actions[actionName] = { name: newActionName }\n  }\n\n  // dereference events\n  for (const [eventName, event] of Object.entries(intrface.definition.events ?? {})) {\n    const resolvedEventSchema = event.schema.dereference(entitySchemas) as sdk.z.AnyZodObject\n    const newEventName = _rename(intrface, eventName)\n    resolved.events[newEventName] = { ...event, schema: resolvedEventSchema }\n    statement.events[eventName] = { name: newEventName }\n  }\n\n  // dereference channels\n  for (const [channelName, channel] of Object.entries(intrface.definition.channels ?? {})) {\n    const messages: Record<string, { schema: sdk.z.AnyZodObject }> = {}\n    for (const [messageName, message] of Object.entries(channel.messages)) {\n      const resolvedMessageSchema = message.schema.dereference(entitySchemas) as sdk.z.AnyZodObject\n      // no renaming for messages as they are already contained within a channel that acts as a namespace\n      messages[messageName] = { ...message, schema: resolvedMessageSchema }\n    }\n    const newChannelName = _rename(intrface, channelName)\n    resolved.channels[newChannelName] = { ...channel, messages }\n    statement.channels[channelName] = { name: newChannelName }\n  }\n\n  return { resolved, statement }\n}\n\nconst _rename = (intrface: InterfaceExtension, name: string) => {\n  if (!intrface.definition.templateName) {\n    return name\n  }\n  const { entities } = intrface\n  const templateProps = _.mapValues(entities, (entity) => entity.name)\n  return utils.template.formatHandleBars(intrface.definition.templateName, { ...templateProps, name })\n}\n\nconst _mergeObjectSchemas = (a: ZodObjectSchema, b: ZodObjectSchema): ZodObjectSchema => {\n  if (a instanceof sdk.z.ZodObject && b instanceof sdk.z.ZodObject) {\n    return a.merge(b)\n  }\n  if (a instanceof sdk.z.ZodRecord && b instanceof sdk.z.ZodRecord) {\n    return sdk.z.record(sdk.z.intersection(a.valueSchema, b.valueSchema))\n  }\n  // TODO: adress this case\n  throw new Error('Cannot merge object schemas with record schemas')\n}\n"],
  "mappings": "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",
  "names": ["_"]
}
