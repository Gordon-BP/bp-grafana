"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var resolve_integration_interfaces_exports = {};
__export(resolve_integration_interfaces_exports, {
  getImplementationStatements: () => getImplementationStatements,
  resolveInterfaces: () => resolveInterfaces
});
module.exports = __toCommonJS(resolve_integration_interfaces_exports);
var import_lodash = __toESM(require("lodash"));
var utils = __toESM(require("../utils"));
const resolveInterfaces = (integration) => {
  const self = integration;
  if (!self.interfaces) {
    return integration;
  }
  for (const intrface of Object.values(self.interfaces)) {
    const { resolved } = _resolveInterface(intrface);
    self.actions = utils.records.mergeRecords(self.actions ?? {}, resolved.actions, _mergeActions);
    self.channels = utils.records.mergeRecords(self.channels ?? {}, resolved.channels, _mergeChannels);
    self.events = utils.records.mergeRecords(self.events ?? {}, resolved.events, _mergeEvents);
  }
  return self;
};
const getImplementationStatements = (integration) => {
  const self = integration;
  if (!self.interfaces) {
    return {};
  }
  const statements = {};
  for (const [interfaceKey, intrface] of Object.entries(self.interfaces)) {
    const { statement } = _resolveInterface(intrface);
    statements[interfaceKey] = statement;
  }
  return statements;
};
const _mergeActions = (a, b) => {
  return {
    ...a,
    ...b,
    input: {
      schema: a.input.schema.merge(b.input.schema)
    },
    output: {
      schema: a.output.schema.merge(b.output.schema)
    }
  };
};
const _mergeEvents = (a, b) => {
  return {
    ...a,
    ...b,
    schema: a.schema.merge(b.schema)
  };
};
const _mergeChannels = (a, b) => {
  const messages = utils.records.mergeRecords(a.messages, b.messages, _mergeMessage);
  return {
    ...a,
    ...b,
    messages
  };
};
const _mergeMessage = (a, b) => {
  return {
    schema: a.schema.merge(b.schema)
  };
};
const _resolveInterface = (intrface) => {
  const id = "id" in intrface ? intrface.id : void 0;
  const {
    definition: { name, version }
  } = intrface;
  const resolved = { actions: {}, events: {}, channels: {} };
  const statement = {
    id,
    name,
    version,
    entities: import_lodash.default.mapValues(intrface.entities, (entity) => ({ name: entity.name })),
    actions: {},
    events: {},
    channels: {}
  };
  const entitySchemas = import_lodash.default.mapValues(intrface.entities, (entity) => entity.schema);
  for (const [actionName, action] of Object.entries(intrface.definition.actions ?? {})) {
    const resolvedInputSchema = action.input.schema.dereference(entitySchemas);
    const resolvedOutputSchema = action.output.schema.dereference(entitySchemas);
    const newActionName = _rename(intrface, actionName);
    resolved.actions[newActionName] = {
      ...action,
      input: { schema: resolvedInputSchema },
      output: { schema: resolvedOutputSchema }
    };
    statement.actions[actionName] = { name: newActionName };
  }
  for (const [eventName, event] of Object.entries(intrface.definition.events ?? {})) {
    const resolvedEventSchema = event.schema.dereference(entitySchemas);
    const newEventName = _rename(intrface, eventName);
    resolved.events[newEventName] = { ...event, schema: resolvedEventSchema };
    statement.events[eventName] = { name: newEventName };
  }
  for (const [channelName, channel] of Object.entries(intrface.definition.channels ?? {})) {
    const messages = {};
    for (const [messageName, message] of Object.entries(channel.messages)) {
      const resolvedMessageSchema = message.schema.dereference(entitySchemas);
      messages[messageName] = { ...message, schema: resolvedMessageSchema };
    }
    const newChannelName = _rename(intrface, channelName);
    resolved.channels[newChannelName] = { ...channel, messages };
    statement.channels[channelName] = { name: newChannelName };
  }
  return { resolved, statement };
};
const _rename = (intrface, name) => {
  if (!intrface.definition.templateName) {
    return name;
  }
  const { entities } = intrface;
  const templateProps = import_lodash.default.mapValues(entities, (entity) => entity.name);
  return utils.template.formatHandleBars(intrface.definition.templateName, { ...templateProps, name });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getImplementationStatements,
  resolveInterfaces
});
//# sourceMappingURL=resolve-integration-interfaces.js.map
