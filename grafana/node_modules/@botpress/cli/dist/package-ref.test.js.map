{
  "version": 3,
  "sources": ["../src/package-ref.test.ts"],
  "sourcesContent": ["import { test, expect, describe } from 'vitest'\nimport { formatPackageRef, PackageRef, parsePackageRef } from './package-ref'\n\nconst path = '/my/path'\nconst prefixedUlid = 'intver_01HF58RDKE3M7K5RJ5XZ7GF6HE'\nconst uuid = 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'\nconst name = 'myintegration'\n\ndescribe('parsePackageRef', () => {\n  test('parse empty string should return undefined', () => {\n    // arrange\n    const ref = ''\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    expect(result).toBeUndefined()\n  })\n\n  test('parse with invalid version should return undefined', () => {\n    // arrange\n    const ref0 = `${name}@lol`\n    const ref1 = `${name}@1`\n    const ref2 = `${name}@1.0`\n    // act\n    const result0 = parsePackageRef(ref0)\n    const result1 = parsePackageRef(ref1)\n    const result2 = parsePackageRef(ref2)\n    // assert\n    expect(result0).toBeUndefined()\n    expect(result1).toBeUndefined()\n    expect(result2).toBeUndefined()\n  })\n\n  test('parse with an absolute path should return path', () => {\n    // arrange\n    const ref = path\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    const expected: PackageRef = { type: 'path', path: ref }\n    expect(result).toEqual(expected)\n  })\n\n  test('parse with a prefixed ULID sets `id` type', () => {\n    // arrange\n    const ref = prefixedUlid\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    const expected: PackageRef = { type: 'id', id: ref }\n    expect(result).toEqual(expected)\n  })\n\n  test('parse with a legacy UUID sets `id` type', () => {\n    // arrange\n    const ref = uuid\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    const expected: PackageRef = { type: 'id', id: ref }\n    expect(result).toEqual(expected)\n  })\n\n  test('parse with a name and version should return name and version', () => {\n    // arrange\n    const version = '1.0.0'\n    const ref = `${name}@${version}`\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    const expected: PackageRef = { type: 'name', name, version }\n    expect(result).toEqual(expected)\n  })\n\n  test('parse with a name and latest should return name and latest', () => {\n    // arrange\n    const version = 'latest'\n    const ref = `${name}@${version}`\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    const expected: PackageRef = { type: 'name', name, version }\n    expect(result).toEqual(expected)\n  })\n\n  test('parse with only a name should return name and latest', () => {\n    // arrange\n    const ref = name\n    // act\n    const result = parsePackageRef(ref)\n    // assert\n    const expected: PackageRef = { type: 'name', name, version: 'latest' }\n    expect(result).toEqual(expected)\n  })\n})\n\ndescribe('formatPackageRef', () => {\n  test('format with a path should return path', () => {\n    // arrange\n    const ref: PackageRef = { type: 'path', path }\n    // act\n    const result = formatPackageRef(ref)\n    // assert\n    expect(result).toEqual(ref.path)\n  })\n\n  test('format with a prefixed ULID uses `id` type', () => {\n    // arrange\n    const ref: PackageRef = { type: 'id', id: prefixedUlid }\n    // act\n    const result = formatPackageRef(ref)\n    // assert\n    expect(result).toEqual(ref.id)\n  })\n\n  test('format with a legacy UUID uses `id` type', () => {\n    // arrange\n    const ref: PackageRef = { type: 'id', id: uuid }\n    // act\n    const result = formatPackageRef(ref)\n    // assert\n    expect(result).toEqual(ref.id)\n  })\n\n  test('format with a name and version should return name and version', () => {\n    // arrange\n    const version = '1.0.0'\n    const ref: PackageRef = { type: 'name', name, version }\n    // act\n    const result = formatPackageRef(ref)\n    // assert\n    expect(result).toEqual(`${name}@${version}`)\n  })\n})\n"],
  "mappings": "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",
  "names": []
}
