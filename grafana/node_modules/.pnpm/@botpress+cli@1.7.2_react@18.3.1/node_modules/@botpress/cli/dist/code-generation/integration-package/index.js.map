{
  "version": 3,
  "sources": ["../../../src/code-generation/integration-package/index.ts"],
  "sourcesContent": ["import * as utils from '../../utils'\nimport * as consts from '../consts'\nimport * as types from '../typings'\nimport { IntegrationPackageDefinitionModule } from './integration-package-definition'\n\nconst generateIntegrationPackageModule = (\n  definitionImport: string,\n  pkg: types.IntegrationInstallablePackage\n): string => {\n  const refLine =\n    pkg.source === 'local' ? `uri: \"${utils.path.win32.escapeBackslashes(pkg.path)}\"` : `id: \"${pkg.integration.id}\"`\n  return [\n    consts.GENERATED_HEADER,\n    'import * as sdk from \"@botpress/sdk\"',\n    '',\n    `import definition from \"${utils.path.win32.escapeBackslashes(definitionImport)}\"`,\n    '',\n    'export default {',\n    '  type: \"integration\",',\n    `  ${refLine},`,\n    '  definition,',\n    '} satisfies sdk.IntegrationPackage',\n  ].join('\\n')\n}\n\nconst generateIntegrationPackageFromRemote = async (\n  pkg: Extract<types.IntegrationInstallablePackage, { source: 'remote' }>\n): Promise<types.File[]> => {\n  const definitionDir = 'definition'\n  const definitionModule = new IntegrationPackageDefinitionModule(pkg.integration)\n  definitionModule.unshift(definitionDir)\n\n  const definitionFiles = await definitionModule.flatten()\n  return [\n    ...definitionFiles,\n    {\n      path: consts.INDEX_FILE,\n      content: generateIntegrationPackageModule(`./${definitionDir}`, pkg),\n    },\n  ]\n}\n\nconst generateIntegrationPackageFromLocal = async (\n  pkg: Extract<types.IntegrationInstallablePackage, { source: 'local' }>\n): Promise<types.File[]> => {\n  let definitionImport: string = utils.path.join(pkg.path, consts.fromWorkDir.integrationDefinition)\n  definitionImport = utils.path.rmExtension(definitionImport)\n  return [\n    {\n      path: consts.INDEX_FILE,\n      content: generateIntegrationPackageModule(definitionImport, pkg),\n    },\n  ]\n}\n\nexport const generateIntegrationPackage = async (pkg: types.IntegrationInstallablePackage): Promise<types.File[]> => {\n  if (pkg.source === 'remote') {\n    return generateIntegrationPackageFromRemote(pkg)\n  }\n  return generateIntegrationPackageFromLocal(pkg)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAuB;AACvB,aAAwB;AAExB,4CAAmD;AAEnD,MAAM,mCAAmC,CACvC,kBACA,QACW;AACX,QAAM,UACJ,IAAI,WAAW,UAAU,SAAS,MAAM,KAAK,MAAM,kBAAkB,IAAI,IAAI,OAAO,QAAQ,IAAI,YAAY;AAC9G,SAAO;AAAA,IACL,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,2BAA2B,MAAM,KAAK,MAAM,kBAAkB,gBAAgB;AAAA,IAC9E;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK;AAAA,IACL;AAAA,IACA;AAAA,EACF,EAAE,KAAK,IAAI;AACb;AAEA,MAAM,uCAAuC,OAC3C,QAC0B;AAC1B,QAAM,gBAAgB;AACtB,QAAM,mBAAmB,IAAI,yEAAmC,IAAI,WAAW;AAC/E,mBAAiB,QAAQ,aAAa;AAEtC,QAAM,kBAAkB,MAAM,iBAAiB,QAAQ;AACvD,SAAO;AAAA,IACL,GAAG;AAAA,IACH;AAAA,MACE,MAAM,OAAO;AAAA,MACb,SAAS,iCAAiC,KAAK,iBAAiB,GAAG;AAAA,IACrE;AAAA,EACF;AACF;AAEA,MAAM,sCAAsC,OAC1C,QAC0B;AAC1B,MAAI,mBAA2B,MAAM,KAAK,KAAK,IAAI,MAAM,OAAO,YAAY,qBAAqB;AACjG,qBAAmB,MAAM,KAAK,YAAY,gBAAgB;AAC1D,SAAO;AAAA,IACL;AAAA,MACE,MAAM,OAAO;AAAA,MACb,SAAS,iCAAiC,kBAAkB,GAAG;AAAA,IACjE;AAAA,EACF;AACF;AAEO,MAAM,6BAA6B,OAAO,QAAoE;AACnH,MAAI,IAAI,WAAW,UAAU;AAC3B,WAAO,qCAAqC,GAAG;AAAA,EACjD;AACA,SAAO,oCAAoC,GAAG;AAChD;",
  "names": []
}
