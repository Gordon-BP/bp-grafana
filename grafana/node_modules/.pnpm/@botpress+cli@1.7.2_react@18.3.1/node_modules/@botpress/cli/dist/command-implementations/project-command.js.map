{
  "version": 3,
  "sources": ["../../src/command-implementations/project-command.ts"],
  "sourcesContent": ["import type * as client from '@botpress/client'\nimport type * as sdk from '@botpress/sdk'\nimport type { YargsConfig } from '@bpinternal/yargs-extra'\nimport bluebird from 'bluebird'\nimport chalk from 'chalk'\nimport fs from 'fs'\nimport _ from 'lodash'\nimport semver from 'semver'\nimport { ApiClient } from '../api/client'\nimport * as codegen from '../code-generation'\nimport type * as config from '../config'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport { formatPackageRef, PackageRef } from '../package-ref'\nimport { validateIntegrationDefinition, resolveInterfaces, resolveBotInterfaces } from '../sdk'\nimport type { CommandArgv, CommandDefinition } from '../typings'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\n\nexport type ProjectCommandDefinition = CommandDefinition<typeof config.schemas.project>\nexport type ProjectCache = { botId: string; devId: string }\n\ntype ConfigurableProjectPaths = { workDir: string }\ntype ConstantProjectPaths = typeof consts.fromWorkDir\ntype AllProjectPaths = ConfigurableProjectPaths & ConstantProjectPaths\n\ntype IntegrationInstance = NonNullable<sdk.BotDefinition['integrations']>[string]\ntype RemoteIntegrationInstance = utils.types.Merge<IntegrationInstance, { id: string }>\ntype LocalIntegrationInstance = utils.types.Merge<IntegrationInstance, { uri?: string }>\ntype BotIntegrationRequest = NonNullable<NonNullable<client.ClientInputs['updateBot']['integrations']>[string]>\n\ntype LintIgnoredConfig = { bpLintDisabled?: boolean }\n\nexport type ProjectType = ProjectDefinition['type']\nexport type ProjectDefinition = LintIgnoredConfig &\n  (\n    | { type: 'integration'; definition: sdk.IntegrationDefinition }\n    | { type: 'interface'; definition: sdk.InterfaceDeclaration }\n    | { type: 'bot'; definition: sdk.BotDefinition }\n  )\n\nclass ProjectPaths extends utils.path.PathStore<keyof AllProjectPaths> {\n  public constructor(argv: CommandArgv<ProjectCommandDefinition>) {\n    const absWorkDir = utils.path.absoluteFrom(utils.path.cwd(), argv.workDir)\n    super({\n      workDir: absWorkDir,\n      ..._.mapValues(consts.fromWorkDir, (p) => utils.path.absoluteFrom(absWorkDir, p)),\n    })\n  }\n}\n\nexport abstract class ProjectCommand<C extends ProjectCommandDefinition> extends GlobalCommand<C> {\n  protected override async bootstrap() {\n    await super.bootstrap()\n    await this._notifyUpdateSdk()\n  }\n\n  protected get projectPaths() {\n    return new ProjectPaths(this.argv)\n  }\n\n  protected get projectCache() {\n    return new utils.cache.FSKeyValueCache<ProjectCache>(this.projectPaths.abs.projectCacheFile)\n  }\n\n  protected async fetchBotIntegrationInstances(\n    botDefinition: sdk.BotDefinition,\n    api: ApiClient\n  ): Promise<Record<string, BotIntegrationRequest>> {\n    const integrationList = _(botDefinition.integrations).values().filter(utils.guards.is.defined).value()\n\n    const { remoteInstances, localInstances } = this._splitApiAndLocalIntegrationInstances(integrationList)\n\n    const fetchedInstances: RemoteIntegrationInstance[] = await bluebird.map(localInstances, async (instance) => {\n      const ref: PackageRef = { type: 'name', name: instance.definition.name, version: instance.definition.version }\n      const integration = await api.findIntegration(ref)\n      if (!integration) {\n        const formattedRef = formatPackageRef(ref)\n        throw new errors.BotpressCLIError(`Integration \"${formattedRef}\" not found`)\n      }\n      return { ...instance, id: integration.id }\n    })\n\n    return _([...fetchedInstances, ...remoteInstances])\n      .keyBy((i) => i.id)\n      .mapValues(({ enabled, configurationType, configuration }) => ({\n        enabled,\n        configurationType: configurationType ?? null,\n        configuration,\n      }))\n      .value()\n  }\n\n  private _splitApiAndLocalIntegrationInstances(instances: IntegrationInstance[]): {\n    remoteInstances: RemoteIntegrationInstance[]\n    localInstances: LocalIntegrationInstance[]\n  } {\n    const remoteInstances: RemoteIntegrationInstance[] = []\n    const localInstances: LocalIntegrationInstance[] = []\n    for (const instance of instances) {\n      if ('id' in instance) {\n        remoteInstances.push(instance)\n      } else {\n        localInstances.push(instance)\n      }\n    }\n\n    return { remoteInstances, localInstances }\n  }\n\n  protected async readProjectDefinitionFromFS(): Promise<ProjectDefinition> {\n    const projectPaths = this.projectPaths\n    try {\n      const integrationDefinition = await this._readIntegrationDefinitionFromFS(projectPaths)\n      if (integrationDefinition) {\n        return { type: 'integration', ...integrationDefinition }\n      }\n      const interfaceDefinition = await this._readInterfaceDefinitionFromFS(projectPaths)\n      if (interfaceDefinition) {\n        return { type: 'interface', ...interfaceDefinition }\n      }\n      const botDefinition = await this._readBotDefinitionFromFS(projectPaths)\n      if (botDefinition) {\n        return { type: 'bot', ...botDefinition }\n      }\n    } catch (thrown: unknown) {\n      throw errors.BotpressCLIError.wrap(thrown, 'Error while reading project definition')\n    }\n\n    throw new errors.ProjectDefinitionNotFoundError(this.projectPaths.abs.workDir)\n  }\n\n  private async _readIntegrationDefinitionFromFS(\n    projectPaths: utils.path.PathStore<'workDir' | 'integrationDefinition'>\n  ): Promise<({ definition: sdk.IntegrationDefinition } & LintIgnoredConfig) | undefined> {\n    const abs = projectPaths.abs\n    const rel = projectPaths.rel('workDir')\n\n    if (!fs.existsSync(abs.integrationDefinition)) {\n      return\n    }\n\n    const bpLintDisabled = await this._isBpLintDisabled(abs.integrationDefinition)\n\n    const { outputFiles } = await utils.esbuild.buildEntrypoint({\n      cwd: abs.workDir,\n      outfile: '',\n      entrypoint: rel.integrationDefinition,\n      write: false,\n      minify: false,\n    })\n\n    const artifact = outputFiles[0]\n    if (!artifact) {\n      throw new errors.BotpressCLIError('Could not read integration definition')\n    }\n\n    let { default: definition } = utils.require.requireJsCode<{ default: sdk.IntegrationDefinition }>(artifact.text)\n    definition = resolveInterfaces(definition)\n    validateIntegrationDefinition(definition)\n    return { definition, bpLintDisabled }\n  }\n\n  private async _readInterfaceDefinitionFromFS(\n    projectPaths: utils.path.PathStore<'workDir' | 'interfaceDefinition'>\n  ): Promise<({ definition: sdk.InterfaceDeclaration } & LintIgnoredConfig) | undefined> {\n    const abs = projectPaths.abs\n    const rel = projectPaths.rel('workDir')\n\n    if (!fs.existsSync(abs.interfaceDefinition)) {\n      return\n    }\n\n    const bpLintDisabled = await this._isBpLintDisabled(abs.interfaceDefinition)\n\n    const { outputFiles } = await utils.esbuild.buildEntrypoint({\n      cwd: abs.workDir,\n      outfile: '',\n      entrypoint: rel.interfaceDefinition,\n      write: false,\n      minify: false,\n    })\n\n    const artifact = outputFiles[0]\n    if (!artifact) {\n      throw new errors.BotpressCLIError('Could not read interface definition')\n    }\n\n    const { default: definition } = utils.require.requireJsCode<{ default: sdk.InterfaceDeclaration }>(artifact.text)\n\n    return { definition, bpLintDisabled }\n  }\n\n  private async _readBotDefinitionFromFS(\n    projectPaths: utils.path.PathStore<'workDir' | 'botDefinition'>\n  ): Promise<({ definition: sdk.BotDefinition } & LintIgnoredConfig) | undefined> {\n    const abs = projectPaths.abs\n    const rel = projectPaths.rel('workDir')\n\n    if (!fs.existsSync(abs.botDefinition)) {\n      return\n    }\n\n    const bpLintDisabled = await this._isBpLintDisabled(abs.botDefinition)\n\n    const { outputFiles } = await utils.esbuild.buildEntrypoint({\n      cwd: abs.workDir,\n      outfile: '',\n      entrypoint: rel.botDefinition,\n      write: false,\n      minify: false,\n    })\n\n    const artifact = outputFiles[0]\n    if (!artifact) {\n      throw new errors.BotpressCLIError('Could not read bot definition')\n    }\n\n    let { default: definition } = utils.require.requireJsCode<{ default: sdk.BotDefinition }>(artifact.text)\n    // TODO: validate bot definition\n\n    definition = resolveBotInterfaces(definition)\n    return { definition, bpLintDisabled }\n  }\n\n  private async _isBpLintDisabled(definitionPath: string): Promise<boolean> {\n    const tsContent = await fs.promises.readFile(definitionPath, 'utf-8')\n    const regex = /\\/\\* bplint-disable \\*\\//\n    return regex.test(tsContent)\n  }\n\n  protected displayWebhookUrls(bot: client.Bot) {\n    if (!_.keys(bot.integrations).length) {\n      this.logger.debug('No integrations in bot')\n      return\n    }\n\n    this.logger.log('Integrations:')\n    for (const integration of Object.values(bot.integrations).filter(utils.guards.is.defined)) {\n      if (!integration.enabled) {\n        this.logger.log(`${chalk.grey(integration.name)} ${chalk.italic('(disabled)')}: ${integration.webhookUrl}`, {\n          prefix: { symbol: '\u25CB', indent: 2 },\n        })\n      } else {\n        this.logger.log(`${chalk.bold(integration.name)} : ${integration.webhookUrl}`, {\n          prefix: { symbol: '\u25CF', indent: 2 },\n        })\n      }\n    }\n  }\n\n  protected async promptSecrets(\n    integrationDef: sdk.IntegrationDefinition,\n    argv: YargsConfig<typeof config.schemas.secrets>,\n    opts: { formatEnv?: boolean; knownSecrets?: string[] } = {}\n  ): Promise<Record<string, string | null>> {\n    const formatEnv = opts.formatEnv ?? false\n    const knownSecrets = opts.knownSecrets ?? []\n\n    const { secrets: secretDefinitions } = integrationDef\n    if (!secretDefinitions) {\n      return {}\n    }\n\n    const secretArgv = this._parseArgvSecrets(argv.secrets)\n    const invalidSecret = Object.keys(secretArgv).find((s) => !secretDefinitions[s])\n    if (invalidSecret) {\n      throw new errors.BotpressCLIError(`Secret ${invalidSecret} is not defined in integration definition`)\n    }\n\n    const values: Record<string, string | null> = {}\n    for (const [secretName, { optional }] of Object.entries(secretDefinitions)) {\n      const argvSecret = secretArgv[secretName]\n      if (argvSecret) {\n        this.logger.debug(`Using secret \"${secretName}\" from argv`)\n        values[secretName] = argvSecret\n        continue\n      }\n\n      const alreadyKnown = knownSecrets.includes(secretName)\n      let mode: string\n      if (alreadyKnown) {\n        mode = 'already set'\n      } else if (optional) {\n        mode = 'optional'\n      } else {\n        mode = 'required'\n      }\n\n      const prompted = await this.prompt.text(`Enter value for secret \"${secretName}\" (${mode})`)\n      if (prompted) {\n        values[secretName] = prompted\n        continue\n      }\n\n      if (alreadyKnown) {\n        this.logger.log(`Secret \"${secretName}\" is unchanged`)\n      } else if (optional) {\n        this.logger.warn(`Secret \"${secretName}\" is unassigned`)\n      } else {\n        throw new errors.BotpressCLIError(`Secret \"${secretName}\" is required`)\n      }\n    }\n\n    for (const secretName of knownSecrets) {\n      const isDefined = secretName in secretDefinitions\n      if (isDefined) {\n        continue\n      }\n      const prompted = await this.prompt.confirm(`Secret \"${secretName}\" was removed. Do you wish to delete it?`)\n      if (prompted) {\n        this.logger.log(`Deleting secret \"${secretName}\"`, { prefix: { symbol: '\u00D7', fg: 'red' } })\n        values[secretName] = null\n      }\n    }\n\n    if (!formatEnv) {\n      return values\n    }\n\n    const envVariables = _.mapKeys(values, (_v, k) => codegen.secretEnvVariableName(k))\n    return envVariables\n  }\n\n  protected async readIntegrationConfigDefinition<C extends client.ClientInputs['createIntegration']['configuration']>(\n    config: C\n  ): Promise<C> {\n    if (!config?.identifier) {\n      return config\n    }\n    return {\n      ...config,\n      identifier: {\n        ...config.identifier,\n        linkTemplateScript: await this.readProjectFile(config.identifier.linkTemplateScript),\n      },\n    }\n  }\n\n  protected readProjectFile = async (filePath: string | undefined): Promise<string | undefined> => {\n    if (!filePath) {\n      return undefined\n    }\n    const absoluteFilePath = utils.path.absoluteFrom(this.projectPaths.abs.workDir, filePath)\n    return fs.promises.readFile(absoluteFilePath, 'utf-8').catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not read file \"${absoluteFilePath}\"`)\n    })\n  }\n\n  private _parseArgvSecrets(argvSecrets: string[]): Record<string, string> {\n    const parsed: Record<string, string> = {}\n    for (const secret of argvSecrets) {\n      const [key, value] = utils.string.splitOnce(secret, '=')\n      if (!value) {\n        throw new errors.BotpressCLIError(\n          `Secret \"${key}\" is missing a value. Expected format: \"SECRET_NAME=secretValue\"`\n        )\n      }\n      parsed[key!] = value\n    }\n\n    return parsed\n  }\n\n  private _notifyUpdateSdk = async (): Promise<void> => {\n    try {\n      this.logger.debug('Checking if sdk is up to date')\n\n      const { workDir } = this.projectPaths.abs\n      const projectPkgJson = await utils.pkgJson.readPackageJson(workDir)\n      if (!projectPkgJson) {\n        this.logger.debug(`Could not find package.json at \"${workDir}\"`)\n        return\n      }\n\n      const sdkPackageName = '@botpress/sdk'\n      const actualSdkVersion = utils.pkgJson.findDependency(projectPkgJson, sdkPackageName)\n      if (!actualSdkVersion) {\n        this.logger.debug(`Could not find dependency \"${sdkPackageName}\" in project package.json`)\n        return\n      }\n\n      if (actualSdkVersion.startsWith('workspace:')) {\n        return\n      }\n\n      const actualCleanedSdkVersion = semver.valid(semver.coerce(actualSdkVersion))\n      if (!actualCleanedSdkVersion) {\n        this.logger.debug(`Invalid sdk version \"${actualSdkVersion}\" in project package.json`)\n        return\n      }\n\n      const cliPkgJson = await this.readPkgJson()\n      const expectedSdkVersion = utils.pkgJson.findDependency(cliPkgJson, sdkPackageName)\n      if (!expectedSdkVersion) {\n        this.logger.debug(`Could not find dependency \"${sdkPackageName}\" in cli package.json`)\n        return\n      }\n\n      const expectedCleanedSdkVersion = semver.valid(semver.coerce(expectedSdkVersion))\n      if (!expectedCleanedSdkVersion) {\n        this.logger.debug(`Invalid sdk version \"${expectedSdkVersion}\" in cli package.json`)\n        return\n      }\n\n      if (semver.eq(actualCleanedSdkVersion, expectedCleanedSdkVersion)) {\n        return\n      }\n\n      const diff = semver.diff(actualCleanedSdkVersion, expectedCleanedSdkVersion)\n      if (!diff) {\n        this.logger.debug(`Could not compare versions \"${actualCleanedSdkVersion}\" and \"${expectedCleanedSdkVersion}\"`)\n        return\n      }\n\n      const errorMsg = `Project SDK version is \"${actualCleanedSdkVersion}\", but expected \"${expectedCleanedSdkVersion}\"`\n      if (utils.semver.releases.lt(diff, 'minor')) {\n        this.logger.debug(`${errorMsg}. This may cause compatibility issues.`)\n        return\n      }\n\n      this.logger.warn(chalk.bold(`${errorMsg}. This will cause compatibility issues.`))\n    } catch (thrown) {\n      const err = errors.BotpressCLIError.map(thrown)\n      this.logger.debug(`Failed to check if sdk is up to date: ${err.message}`)\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["_", "bluebird", "fs", "chalk", "semver"]
}
