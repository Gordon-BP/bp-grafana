{
  "version": 3,
  "sources": ["../../src/command-implementations/deploy-command.ts"],
  "sourcesContent": ["import type * as client from '@botpress/client'\nimport * as sdk from '@botpress/sdk'\nimport chalk from 'chalk'\nimport * as fs from 'fs'\nimport semver from 'semver'\nimport { prepareCreateBotBody, prepareUpdateBotBody } from '../api/bot-body'\nimport type { ApiClient } from '../api/client'\nimport {\n  CreateIntegrationBody,\n  prepareUpdateIntegrationBody,\n  prepareCreateIntegrationBody,\n} from '../api/integration-body'\nimport { CreateInterfaceBody, prepareCreateInterfaceBody, prepareUpdateInterfaceBody } from '../api/interface-body'\nimport type commandDefinitions from '../command-definitions'\nimport * as errors from '../errors'\nimport { getImplementationStatements } from '../sdk'\nimport * as utils from '../utils'\nimport { BuildCommand } from './build-command'\nimport { ProjectCommand } from './project-command'\n\nexport type DeployCommandDefinition = typeof commandDefinitions.deploy\nexport class DeployCommand extends ProjectCommand<DeployCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n\n    if (!this.argv.noBuild) {\n      await this._runBuild() // This ensures the bundle is always synced with source code\n    }\n\n    const projectDef = await this.readProjectDefinitionFromFS()\n\n    if (projectDef.type === 'integration') {\n      return this._deployIntegration(api, projectDef.definition)\n    }\n    if (projectDef.type === 'interface') {\n      return this._deployInterface(api, projectDef.definition)\n    }\n    if (projectDef.type === 'bot') {\n      return this._deployBot(api, projectDef.definition, this.argv.botId, this.argv.createNewBot)\n    }\n    throw new errors.UnsupportedProjectType()\n  }\n\n  private async _runBuild() {\n    return new BuildCommand(this.api, this.prompt, this.logger, this.argv).run()\n  }\n\n  private async _deployIntegration(api: ApiClient, integrationDef: sdk.IntegrationDefinition) {\n    const outfile = this.projectPaths.abs.outFile\n    const code = await fs.promises.readFile(outfile, 'utf-8')\n\n    integrationDef = await this._manageWorkspaceHandle(api, integrationDef)\n\n    const { name, version, icon: iconRelativeFilePath, readme: readmeRelativeFilePath, identifier } = integrationDef\n\n    if (iconRelativeFilePath && !iconRelativeFilePath.toLowerCase().endsWith('.svg')) {\n      throw new errors.BotpressCLIError('Icon must be an SVG file')\n    }\n\n    const iconFileContent = await this._readMediaFile('icon', iconRelativeFilePath)\n    const readmeFileContent = await this._readMediaFile('readme', readmeRelativeFilePath)\n    const identifierExtractScriptFileContent = await this.readProjectFile(identifier?.extractScript)\n    const fallbackHandlerScriptFileContent = await this.readProjectFile(identifier?.fallbackHandlerScript)\n\n    const integration = await api.findIntegration({ type: 'name', name, version })\n    if (integration && integration.workspaceId !== api.workspaceId) {\n      throw new errors.BotpressCLIError(\n        `Public integration ${name} v${version} is already deployed in another workspace.`\n      )\n    }\n\n    if (integration && integration.public && !api.isBotpressWorkspace) {\n      throw new errors.BotpressCLIError(\n        `Integration ${name} v${version} is already deployed publicly and cannot be updated. Please bump the version.`\n      )\n    }\n\n    let message: string\n    if (integration) {\n      this.logger.warn('Integration already exists. If you decide to deploy, it will override the existing one.')\n      message = `Are you sure you want to override integration ${name} v${version}?`\n    } else {\n      message = `Are you sure you want to deploy integration ${name} v${version}?`\n    }\n\n    const confirm = await this.prompt.confirm(message)\n    if (!confirm) {\n      this.logger.log('Aborted')\n      return\n    }\n\n    this.logger.debug('Preparing integration request body...')\n\n    let createBody: CreateIntegrationBody = await prepareCreateIntegrationBody(integrationDef)\n    createBody = {\n      ...createBody,\n      interfaces: await this._formatInterfacesImplStatements(api, integrationDef),\n      code,\n      icon: iconFileContent,\n      readme: readmeFileContent,\n      configuration: await this.readIntegrationConfigDefinition(createBody.configuration),\n      configurations: await utils.promises.awaitRecord(\n        utils.records.mapValues(createBody.configurations ?? {}, this.readIntegrationConfigDefinition.bind(this))\n      ),\n      identifier: {\n        extractScript: identifierExtractScriptFileContent,\n        fallbackHandlerScript: fallbackHandlerScriptFileContent,\n      },\n      public: this.argv.public,\n    }\n\n    const startedMessage = `Deploying integration ${chalk.bold(name)} v${version}...`\n    const successMessage = 'Integration deployed'\n    if (integration) {\n      const updateBody = prepareUpdateIntegrationBody(\n        {\n          id: integration.id,\n          ...createBody,\n          public: this.argv.public,\n        },\n        integration\n      )\n\n      const { secrets: knownSecrets } = integration\n      updateBody.secrets = await this.promptSecrets(integrationDef, this.argv, { knownSecrets })\n      this._detectDeprecatedFeatures(integrationDef, { allowDeprecated: true })\n\n      const line = this.logger.line()\n      line.started(startedMessage)\n      await api.client.updateIntegration(updateBody).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not update integration \"${name}\"`)\n      })\n      line.success(successMessage)\n    } else {\n      this.logger.debug(`looking for previous version of integration \"${name}\"`)\n      const previousVersion = await api.findPreviousIntegrationVersion({ type: 'name', name, version })\n\n      if (previousVersion) {\n        this.logger.debug(`previous version found: ${previousVersion.version}`)\n      } else {\n        this.logger.debug('no previous version found')\n      }\n\n      const knownSecrets = previousVersion?.secrets\n\n      const createSecrets = await this.promptSecrets(integrationDef, this.argv, { knownSecrets })\n      createBody.secrets = utils.records.filterValues(createSecrets, utils.guards.is.notNull)\n\n      this._detectDeprecatedFeatures(integrationDef, {\n        allowDeprecated: this._allowDeprecatedFeatures(integrationDef, previousVersion),\n      })\n\n      const line = this.logger.line()\n      line.started(startedMessage)\n      await api.client.createIntegration(createBody).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not create integration \"${name}\"`)\n      })\n      line.success(successMessage)\n    }\n  }\n\n  private async _deployInterface(api: ApiClient, interfaceDeclaration: sdk.InterfaceDeclaration) {\n    if (!api.isBotpressWorkspace) {\n      throw new errors.BotpressCLIError('Your workspace is not allowed to deploy interfaces.')\n    }\n\n    const { name, version } = interfaceDeclaration\n    const intrface = await api.findPublicInterface({ type: 'name', name, version })\n\n    let message: string\n    if (intrface) {\n      this.logger.warn('Interface already exists. If you decide to deploy, it will override the existing one.')\n      message = `Are you sure you want to override interface ${name} v${version}?`\n    } else {\n      message = `Are you sure you want to deploy interface ${name} v${version}?`\n    }\n\n    const confirm = await this.prompt.confirm(message)\n    if (!confirm) {\n      this.logger.log('Aborted')\n      return\n    }\n\n    const createBody: CreateInterfaceBody = await prepareCreateInterfaceBody(interfaceDeclaration)\n\n    const startedMessage = `Deploying interface ${chalk.bold(name)} v${version}...`\n    const successMessage = 'Interface deployed'\n    if (intrface) {\n      const updateBody = prepareUpdateInterfaceBody(\n        {\n          id: intrface.id,\n          ...createBody,\n        },\n        intrface\n      )\n\n      const line = this.logger.line()\n      line.started(startedMessage)\n      await api.client.updateInterface(updateBody).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not update interface \"${name}\"`)\n      })\n      line.success(successMessage)\n    } else {\n      const line = this.logger.line()\n      line.started(startedMessage)\n      await api.client.createInterface(createBody).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not create interface \"${name}\"`)\n      })\n      line.success(successMessage)\n    }\n  }\n\n  private _allowDeprecatedFeatures(\n    integrationDef: sdk.IntegrationDefinition,\n    previousVersion: client.Integration | undefined\n  ): boolean {\n    if (this.argv.allowDeprecated) {\n      return true\n    }\n\n    if (!previousVersion) {\n      return false\n    }\n\n    const versionDiff = semver.diff(integrationDef.version, previousVersion.version)\n    if (!versionDiff) {\n      return false\n    }\n\n    return utils.semver.releases.lt(versionDiff, 'major')\n  }\n\n  private _detectDeprecatedFeatures(\n    integrationDef: sdk.IntegrationDefinition,\n    opts: { allowDeprecated?: boolean } = {}\n  ) {\n    const deprecatedFields: string[] = []\n    const { user, channels } = integrationDef\n    if (user?.creation?.enabled) {\n      deprecatedFields.push('user.creation')\n    }\n\n    for (const [channelName, channel] of Object.entries(channels ?? {})) {\n      if (channel?.conversation?.creation?.enabled) {\n        deprecatedFields.push(`channels.${channelName}.creation`)\n      }\n    }\n\n    if (!deprecatedFields.length) {\n      return\n    }\n\n    const errorMessage = `The following fields of the integration's definition are deprecated: ${deprecatedFields.join(\n      ', '\n    )}`\n\n    if (opts.allowDeprecated) {\n      this.logger.warn(errorMessage)\n    } else {\n      throw new errors.BotpressCLIError(errorMessage)\n    }\n  }\n\n  private _readMediaFile = async (\n    filePurpose: 'icon' | 'readme',\n    filePath: string | undefined\n  ): Promise<string | undefined> => {\n    if (!filePath) {\n      return undefined\n    }\n\n    const absoluteFilePath = utils.path.absoluteFrom(this.projectPaths.abs.workDir, filePath)\n    return fs.promises.readFile(absoluteFilePath, 'base64').catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not read ${filePurpose} file \"${absoluteFilePath}\"`)\n    })\n  }\n\n  private async _deployBot(\n    api: ApiClient,\n    botDefinition: sdk.BotDefinition,\n    argvBotId: string | undefined,\n    argvCreateNew: boolean | undefined\n  ) {\n    const outfile = this.projectPaths.abs.outFile\n    const code = await fs.promises.readFile(outfile, 'utf-8')\n\n    let bot: client.Bot\n    if (argvBotId && argvCreateNew) {\n      throw new errors.BotpressCLIError('Cannot specify both --botId and --createNew')\n    } else if (argvCreateNew) {\n      const confirm = await this.prompt.confirm('Are you sure you want to create a new bot ?')\n      if (!confirm) {\n        this.logger.log('Aborted')\n        return\n      }\n\n      bot = await this._createNewBot(api)\n    } else {\n      bot = await this._getExistingBot(api, argvBotId)\n\n      const confirm = await this.prompt.confirm(`Are you sure you want to deploy the bot \"${bot.name}\"?`)\n      if (!confirm) {\n        this.logger.log('Aborted')\n        return\n      }\n    }\n\n    const line = this.logger.line()\n    line.started(`Deploying bot ${chalk.bold(bot.name)}...`)\n\n    const integrationInstances = await this.fetchBotIntegrationInstances(botDefinition, api)\n    const createBotBody = await prepareCreateBotBody(botDefinition)\n    const updateBotBody = prepareUpdateBotBody(\n      {\n        ...createBotBody,\n        id: bot.id,\n        code,\n        integrations: integrationInstances,\n      },\n      bot\n    )\n\n    const { bot: updatedBot } = await api.client.updateBot(updateBotBody).catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not update bot \"${bot.name}\"`)\n    })\n    line.success('Bot deployed')\n    this.displayWebhookUrls(updatedBot)\n  }\n\n  private async _createNewBot(api: ApiClient): Promise<client.Bot> {\n    const line = this.logger.line()\n    const { bot: createdBot } = await api.client.createBot({}).catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not create bot')\n    })\n    line.success(`Bot created with ID \"${createdBot.id}\" and name \"${createdBot.name}\"`)\n    await this.projectCache.set('botId', createdBot.id)\n    return createdBot\n  }\n\n  private async _getExistingBot(api: ApiClient, botId: string | undefined): Promise<client.Bot> {\n    const promptedBotId = await this.projectCache.sync('botId', botId, async (defaultId) => {\n      const userBots = await api\n        .listAllPages(api.client.listBots, (r) => r.bots)\n        .catch((thrown) => {\n          throw errors.BotpressCLIError.wrap(thrown, 'Could not fetch existing bots')\n        })\n\n      if (!userBots.length) {\n        throw new errors.NoBotsFoundError()\n      }\n\n      const initial = userBots.find((bot) => bot.id === defaultId)\n\n      const prompted = await this.prompt.select('Which bot do you want to deploy?', {\n        initial: initial && { title: initial.name, value: initial.id },\n        choices: userBots.map((bot) => ({ title: bot.name, value: bot.id })),\n      })\n\n      if (!prompted) {\n        throw new errors.ParamRequiredError('Bot Id')\n      }\n\n      return prompted\n    })\n\n    const { bot: fetchedBot } = await api.client.getBot({ id: promptedBotId }).catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not get bot info')\n    })\n\n    return fetchedBot\n  }\n\n  private async _manageWorkspaceHandle(\n    api: ApiClient,\n    integration: sdk.IntegrationDefinition\n  ): Promise<sdk.IntegrationDefinition> {\n    const { name: localName, workspaceHandle: localHandle } = this._parseIntegrationName(integration.name)\n    if (!localHandle && api.isBotpressWorkspace) {\n      this.logger.debug('Botpress workspace detected; workspace handle omitted')\n      return integration // botpress has the right to omit workspace handle\n    }\n\n    const { handle: remoteHandle, name: workspaceName } = await api.getWorkspace().catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not fetch workspace')\n    })\n\n    if (localHandle && remoteHandle) {\n      if (localHandle !== remoteHandle) {\n        throw new errors.BotpressCLIError(\n          `Your current workspace handle is \"${remoteHandle}\" but the integration handle is \"${localHandle}\".`\n        )\n      }\n      return integration\n    }\n\n    const workspaceHandleIsMandatoryMsg = 'Cannot deploy integration without workspace handle'\n\n    if (!localHandle && remoteHandle) {\n      const confirmAddHandle = await this.prompt.confirm(\n        `Your current workspace handle is \"${remoteHandle}\". Do you want to use the name \"${remoteHandle}/${localName}\"?`\n      )\n      if (!confirmAddHandle) {\n        throw new errors.BotpressCLIError(workspaceHandleIsMandatoryMsg)\n      }\n      const newName = `${remoteHandle}/${localName}`\n      return new sdk.IntegrationDefinition({ ...integration, name: newName })\n    }\n\n    if (localHandle && !remoteHandle) {\n      const { available } = await api.client.checkHandleAvailability({ handle: localHandle }).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, 'Could not check handle availability')\n      })\n\n      if (!available) {\n        throw new errors.BotpressCLIError(`Handle \"${localHandle}\" is not yours and is not available`)\n      }\n\n      const confirmClaimHandle = await this.prompt.confirm(\n        `Handle \"${localHandle}\" is available. Do you want to claim it for your workspace ${workspaceName}?`\n      )\n      if (!confirmClaimHandle) {\n        throw new errors.BotpressCLIError(workspaceHandleIsMandatoryMsg)\n      }\n\n      await api.updateWorkspace({ handle: localHandle }).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not claim handle \"${localHandle}\"`)\n      })\n\n      this.logger.success(`Handle \"${localHandle}\" is now yours!`)\n      return integration\n    }\n\n    this.logger.warn(\"It seems you don't have a workspace handle yet.\")\n    let claimedHandle: string | undefined = undefined\n    do {\n      const prompted = await this.prompt.text('Please enter a workspace handle')\n      if (!prompted) {\n        throw new errors.BotpressCLIError(workspaceHandleIsMandatoryMsg)\n      }\n\n      const { available, suggestions } = await api.client.checkHandleAvailability({ handle: prompted })\n      if (!available) {\n        this.logger.warn(`Handle \"${prompted}\" is not available. Suggestions: ${suggestions.join(', ')}`)\n        continue\n      }\n\n      claimedHandle = prompted\n      await api.updateWorkspace({ handle: claimedHandle }).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not claim handle \"${claimedHandle}\"`)\n      })\n    } while (!claimedHandle)\n\n    this.logger.success(`Handle \"${claimedHandle}\" is yours!`)\n    const newName = `${claimedHandle}/${localName}`\n    return new sdk.IntegrationDefinition({ ...integration, name: newName })\n  }\n\n  private _parseIntegrationName = (integrationName: string): { name: string; workspaceHandle?: string } => {\n    const parts = integrationName.split('/')\n    if (parts.length > 2) {\n      throw new errors.BotpressCLIError(\n        `Invalid integration name \"${integrationName}\": a single forward slash is allowed`\n      )\n    }\n    if (parts.length === 2) {\n      const [workspaceHandle, name] = parts as [string, string]\n      return { name, workspaceHandle }\n    }\n    const [name] = parts as [string]\n    return { name }\n  }\n\n  private _formatInterfacesImplStatements = async (\n    api: ApiClient,\n    integration: sdk.IntegrationDefinition\n  ): Promise<CreateIntegrationBody['interfaces']> => {\n    const interfacesStatements = getImplementationStatements(integration)\n    const interfaces: NonNullable<CreateIntegrationBody['interfaces']> = {}\n    for (const [key, i] of Object.entries(interfacesStatements)) {\n      const { name, version, entities, actions, events, channels } = i\n      const id = await this._getInterfaceId(api, { id: i.id, name, version })\n      interfaces[key] = { id, entities, actions, events, channels }\n    }\n\n    return interfaces\n  }\n\n  private _getInterfaceId = async (\n    api: ApiClient,\n    ref: { id?: string; name: string; version: string }\n  ): Promise<string> => {\n    if (ref.id) {\n      return ref.id\n    }\n    const intrface = await api.findPublicInterface({ type: 'name', name: ref.name, version: ref.version })\n    if (!intrface) {\n      throw new errors.BotpressCLIError(`Could not find interface \"${ref.name}@${ref.version}\"`)\n    }\n    return intrface.id\n  }\n}\n"],
  "mappings": "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",
  "names": ["chalk", "semver", "newName", "name"]
}
