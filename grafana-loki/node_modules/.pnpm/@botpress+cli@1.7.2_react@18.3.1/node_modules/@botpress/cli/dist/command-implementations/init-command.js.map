{
  "version": 3,
  "sources": ["../../src/command-implementations/init-command.ts"],
  "sourcesContent": ["import chalk from 'chalk'\nimport * as fs from 'fs'\nimport * as pathlib from 'path'\nimport type commandDefinitions from '../command-definitions'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\n\ntype ProjectType = 'bot' | 'integration'\n\nexport type InitCommandDefinition = typeof commandDefinitions.init\nexport class InitCommand extends GlobalCommand<InitCommandDefinition> {\n  public async run(): Promise<void> {\n    let { type: projectType } = this.argv\n\n    if (!projectType) {\n      const promptedType = await this.prompt.select('What type of project do you wish to initialize?', {\n        choices: (['bot', 'integration'] as const).map((t) => ({ title: t, value: t })),\n      })\n\n      if (!promptedType) {\n        throw new errors.ParamRequiredError('Project Type')\n      }\n\n      projectType = promptedType\n    }\n\n    const workDir = utils.path.absoluteFrom(utils.path.cwd(), this.argv.workDir)\n\n    if (projectType === 'bot') {\n      await this._initBot({ workDir })\n      return\n    }\n\n    await this._initIntegration({ workDir })\n    return\n  }\n\n  private _initBot = async (args: { workDir: string }) => {\n    const { workDir } = args\n    const name = await this._getName('bot', consts.emptyBotDirName)\n    await this._copy({ srcDir: this.globalPaths.abs.emptyBotTemplate, destDir: workDir, name })\n    this.logger.success(`Bot project initialized in ${chalk.bold(workDir)}`)\n  }\n\n  private _initIntegration = async (args: { workDir: string }) => {\n    const { workDir } = args\n\n    const template = await this.prompt.select('Which template do you want to use?', {\n      choices: [\n        { title: 'Empty Integration', value: consts.emptyIntegrationDirName },\n        { title: 'Hello World', value: consts.helloWorldIntegrationDirName },\n        { title: 'Webhook Message', value: consts.webhookMessageIntegrationDirName },\n      ],\n      default: consts.emptyIntegrationDirName,\n    })\n\n    let srcDirPath: string\n    if (template === consts.helloWorldIntegrationDirName) {\n      srcDirPath = this.globalPaths.abs.helloWorldIntegrationTemplate\n    } else if (template === consts.webhookMessageIntegrationDirName) {\n      srcDirPath = this.globalPaths.abs.webhookMessageIntegrationTemplate\n    } else {\n      srcDirPath = this.globalPaths.abs.emptyIntegrationTemplate\n    }\n\n    const name = await this._getName('integration', template ?? consts.emptyIntegrationDirName)\n\n    await this._copy({ srcDir: srcDirPath, destDir: workDir, name })\n    this.logger.success(`Integration project initialized in ${chalk.bold(this.argv.workDir)}`)\n    return\n  }\n\n  private _getName = async (projectType: ProjectType, defaultName: string): Promise<string> => {\n    if (this.argv.name) {\n      return this.argv.name\n    }\n    const promptMessage = `What is the name of your ${projectType}?`\n    const promptedName = await this.prompt.text(promptMessage, { initial: defaultName })\n    if (!promptedName) {\n      throw new errors.ParamRequiredError('Project Name')\n    }\n    return promptedName\n  }\n\n  private _copy = async (props: { srcDir: string; destDir: string; name: string }) => {\n    const { srcDir, destDir, name } = props\n\n    const dirName = utils.casing.to.kebabCase(name)\n    const destination = pathlib.join(destDir, dirName)\n\n    const exist = await this._checkIfDestinationExists(destination)\n    if (exist) {\n      return\n    }\n\n    await fs.promises.cp(srcDir, destination, { recursive: true })\n\n    const pkgJsonPath = pathlib.join(destination, 'package.json')\n    const strContent = await fs.promises.readFile(pkgJsonPath, 'utf-8')\n    const { name: _, integrationName: __, ...json } = JSON.parse(strContent)\n\n    const pkgJsonName = utils.casing.to.snakeCase(name)\n    const updatedJson = { name: pkgJsonName, integrationName: name, ...json }\n    await fs.promises.writeFile(pkgJsonPath, JSON.stringify(updatedJson, null, 2))\n  }\n\n  private _checkIfDestinationExists = async (destination: string) => {\n    if (fs.existsSync(destination)) {\n      const override = await this.prompt.confirm(\n        `Directory ${chalk.bold(destination)} already exists. Do you want to overwrite it?`\n      )\n      if (!override) {\n        this.logger.log('Aborting')\n        return true\n      }\n    }\n    return false\n  }\n}\n"],
  "mappings": "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",
  "names": ["chalk"]
}
