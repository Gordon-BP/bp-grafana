{
  "version": 3,
  "sources": ["../../src/command-implementations/add-command.ts"],
  "sourcesContent": ["import * as fslib from 'fs'\nimport * as pathlib from 'path'\nimport { ApiClient } from '../api'\nimport * as codegen from '../code-generation'\nimport type commandDefinitions from '../command-definitions'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport * as pkgRef from '../package-ref'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\nimport { ProjectCommand, ProjectCommandDefinition, ProjectDefinition } from './project-command'\n\ntype InstallablePackage =\n  | {\n      type: 'integration'\n      name: string\n      pkg: codegen.IntegrationInstallablePackage\n    }\n  | {\n      type: 'interface'\n      name: string\n      pkg: codegen.InterfaceInstallablePackage\n    }\n\nexport type AddCommandDefinition = typeof commandDefinitions.add\nexport class AddCommand extends GlobalCommand<AddCommandDefinition> {\n  public async run(): Promise<void> {\n    const parsedRef = pkgRef.parsePackageRef(this.argv.packageRef)\n    if (!parsedRef) {\n      throw new errors.InvalidPackageReferenceError(this.argv.packageRef)\n    }\n\n    const targetPackage =\n      parsedRef.type === 'path' ? await this._findLocalPackage(parsedRef) : await this._findRemotePackage(parsedRef)\n\n    if (!targetPackage) {\n      const notFoundMessage = this.argv.packageType\n        ? `Could not find package \"${this.argv.packageRef}\" of type \"${this.argv.packageType}\"`\n        : `Could not find package \"${this.argv.packageRef}\"`\n      throw new errors.BotpressCLIError(notFoundMessage)\n    }\n\n    const packageName = targetPackage.name // TODO: eventually replace name by alias (with argv --alias)\n    const baseInstallPath = utils.path.absoluteFrom(utils.path.cwd(), this.argv.installPath)\n    const packageDirName = utils.casing.to.kebabCase(packageName)\n    const installPath = utils.path.join(baseInstallPath, consts.installDirName, packageDirName)\n\n    const alreadyInstalled = fslib.existsSync(installPath)\n    if (alreadyInstalled) {\n      this.logger.warn(`Package with name \"${packageName}\" already installed.`)\n      const res = await this.prompt.confirm('Do you want to overwrite the existing package?')\n      if (!res) {\n        this.logger.log('Aborted')\n        return\n      }\n\n      await this._uninstall(installPath)\n    }\n\n    let files: codegen.File[]\n    if (targetPackage.type === 'integration') {\n      files = await codegen.generateIntegrationPackage(targetPackage.pkg)\n    } else {\n      files = await codegen.generateInterfacePackage(targetPackage.pkg)\n    }\n\n    await this._install(installPath, files)\n  }\n\n  private async _findRemotePackage(ref: pkgRef.ApiPackageRef): Promise<InstallablePackage | undefined> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n    if (this._pkgCouldBe('integration')) {\n      const integration = await api.findIntegration(ref)\n      if (integration) {\n        return { type: 'integration', name: integration.name, pkg: { source: 'remote', integration } }\n      }\n    }\n    if (this._pkgCouldBe('interface')) {\n      const intrface = await api.findPublicInterface(ref)\n      if (intrface) {\n        return { type: 'interface', name: intrface.name, pkg: { source: 'remote', interface: intrface } }\n      }\n    }\n    return\n  }\n\n  private async _findLocalPackage(ref: pkgRef.LocalPackageRef): Promise<InstallablePackage | undefined> {\n    const absPath = utils.path.absoluteFrom(utils.path.cwd(), ref.path)\n    const projectDefinition = await this._readProject(absPath)\n    if (this._pkgCouldBe('integration') && projectDefinition?.type === 'integration') {\n      return {\n        type: 'integration',\n        name: projectDefinition.definition.name,\n        pkg: { source: 'local', path: absPath },\n      }\n    }\n    if (this._pkgCouldBe('interface') && projectDefinition?.type === 'interface') {\n      return {\n        type: 'interface',\n        name: projectDefinition.definition.name,\n        pkg: { source: 'local', path: absPath },\n      }\n    }\n    if (projectDefinition?.type === 'bot') {\n      throw new errors.BotpressCLIError('Cannot install a bot as a package')\n    }\n    return\n  }\n\n  private async _install(installPath: utils.path.AbsolutePath, files: codegen.File[]): Promise<void> {\n    const line = this.logger.line()\n    line.started(`Installing ${files.length} files to \"${installPath}\"`)\n    try {\n      for (const file of files) {\n        const filePath = utils.path.absoluteFrom(installPath, file.path)\n        const dirPath = pathlib.dirname(filePath)\n        await fslib.promises.mkdir(dirPath, { recursive: true })\n        await fslib.promises.writeFile(filePath, file.content)\n      }\n      line.success(`Installed ${files.length} files to \"${installPath}\"`)\n    } finally {\n      line.commit()\n    }\n  }\n\n  private async _uninstall(installPath: utils.path.AbsolutePath): Promise<void> {\n    await fslib.promises.rm(installPath, { recursive: true })\n  }\n\n  private async _readProject(workDir: utils.path.AbsolutePath): Promise<ProjectDefinition | undefined> {\n    // this is a hack to avoid refactoring the project command class\n    class AnyProjectCommand extends ProjectCommand<ProjectCommandDefinition> {\n      public async run(): Promise<void> {\n        throw new errors.BotpressCLIError('Not implemented')\n      }\n\n      public async readProjectDefinitionFromFS(): Promise<ProjectDefinition> {\n        return super.readProjectDefinitionFromFS()\n      }\n    }\n\n    const cmd = new AnyProjectCommand(ApiClient, this.prompt, this.logger, {\n      ...this.argv,\n      workDir,\n    })\n\n    return cmd.readProjectDefinitionFromFS().catch((thrown) => {\n      if (thrown instanceof errors.ProjectDefinitionNotFoundError) {\n        return undefined\n      }\n      throw thrown\n    })\n  }\n\n  private _pkgCouldBe = (pkgType: InstallablePackage['type']) => {\n    if (!this.argv.packageType) {\n      return true\n    }\n    return this.argv.packageType === pkgType\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
