{
  "version": 3,
  "sources": ["../../src/command-implementations/interface-commands.ts"],
  "sourcesContent": ["import type * as client from '@botpress/client'\nimport chalk from 'chalk'\nimport type commandDefinitions from '../command-definitions'\nimport * as errors from '../errors'\nimport { parsePackageRef } from '../package-ref'\nimport { GlobalCommand } from './global-command'\n\nexport type GetInterfaceCommandDefinition = typeof commandDefinitions.interfaces.subcommands.get\nexport class GetInterfaceCommand extends GlobalCommand<GetInterfaceCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n    const parsedRef = parsePackageRef(this.argv.interfaceRef)\n    if (!parsedRef) {\n      throw new errors.InvalidPackageReferenceError(this.argv.interfaceRef)\n    }\n    if (parsedRef.type === 'path') {\n      throw new errors.BotpressCLIError('Cannot get local interface')\n    }\n\n    try {\n      const intrface = await api.findPublicInterface(parsedRef)\n      if (intrface) {\n        this.logger.success(`Interface ${chalk.bold(this.argv.interfaceRef)}:`)\n        this.logger.json(intrface)\n        return\n      }\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not get interface ${this.argv.interfaceRef}`)\n    }\n\n    throw new errors.BotpressCLIError(`Interface ${this.argv.interfaceRef} not found`)\n  }\n}\n\nexport type ListInterfacesCommandDefinition = typeof commandDefinitions.interfaces.subcommands.list\nexport class ListInterfacesCommand extends GlobalCommand<ListInterfacesCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n\n    const lister = (req: { nextToken?: string }) => api.client.listInterfaces({ nextToken: req.nextToken })\n\n    try {\n      const interfaces = await api.listAllPages(lister, (r) => r.interfaces)\n\n      this.logger.success('Interfaces:')\n      this.logger.json(interfaces)\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not list interfaces')\n    }\n  }\n}\n\nexport type DeleteInterfaceCommandDefinition = typeof commandDefinitions.interfaces.subcommands.delete\nexport class DeleteInterfaceCommand extends GlobalCommand<DeleteInterfaceCommandDefinition> {\n  public async run(): Promise<void> {\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n    const parsedRef = parsePackageRef(this.argv.interfaceRef)\n    if (!parsedRef) {\n      throw new errors.InvalidPackageReferenceError(this.argv.interfaceRef)\n    }\n    if (parsedRef.type === 'path') {\n      throw new errors.BotpressCLIError('Cannot delete local interface')\n    }\n\n    let intrface: client.Interface | undefined\n    try {\n      intrface = await api.findPublicInterface(parsedRef)\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not get interface ${this.argv.interfaceRef}`)\n    }\n\n    if (!intrface) {\n      throw new errors.BotpressCLIError(`Interface ${this.argv.interfaceRef} not found`)\n    }\n\n    try {\n      await api.client.deleteInterface({ id: intrface.id })\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, `Could not delete interface ${this.argv.interfaceRef}`)\n    }\n\n    this.logger.success(`Interface ${chalk.bold(this.argv.interfaceRef)} deleted`)\n    return\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAkB;AAElB,aAAwB;AACxB,yBAAgC;AAChC,4BAA8B;AAGvB,MAAM,4BAA4B,oCAA6C;AAAA,EACpF,MAAa,MAAqB;AAChC,UAAM,MAAM,MAAM,KAAK,2BAA2B,KAAK,IAAI;AAC3D,UAAM,gBAAY,oCAAgB,KAAK,KAAK,YAAY;AACxD,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,OAAO,6BAA6B,KAAK,KAAK,YAAY;AAAA,IACtE;AACA,QAAI,UAAU,SAAS,QAAQ;AAC7B,YAAM,IAAI,OAAO,iBAAiB,4BAA4B;AAAA,IAChE;AAEA,QAAI;AACF,YAAM,WAAW,MAAM,IAAI,oBAAoB,SAAS;AACxD,UAAI,UAAU;AACZ,aAAK,OAAO,QAAQ,aAAa,aAAAA,QAAM,KAAK,KAAK,KAAK,YAAY,IAAI;AACtE,aAAK,OAAO,KAAK,QAAQ;AACzB;AAAA,MACF;AAAA,IACF,SAAS,QAAP;AACA,YAAM,OAAO,iBAAiB,KAAK,QAAQ,2BAA2B,KAAK,KAAK,cAAc;AAAA,IAChG;AAEA,UAAM,IAAI,OAAO,iBAAiB,aAAa,KAAK,KAAK,wBAAwB;AAAA,EACnF;AACF;AAGO,MAAM,8BAA8B,oCAA+C;AAAA,EACxF,MAAa,MAAqB;AAChC,UAAM,MAAM,MAAM,KAAK,2BAA2B,KAAK,IAAI;AAE3D,UAAM,SAAS,CAAC,QAAgC,IAAI,OAAO,eAAe,EAAE,WAAW,IAAI,UAAU,CAAC;AAEtG,QAAI;AACF,YAAM,aAAa,MAAM,IAAI,aAAa,QAAQ,CAAC,MAAM,EAAE,UAAU;AAErE,WAAK,OAAO,QAAQ,aAAa;AACjC,WAAK,OAAO,KAAK,UAAU;AAAA,IAC7B,SAAS,QAAP;AACA,YAAM,OAAO,iBAAiB,KAAK,QAAQ,2BAA2B;AAAA,IACxE;AAAA,EACF;AACF;AAGO,MAAM,+BAA+B,oCAAgD;AAAA,EAC1F,MAAa,MAAqB;AAChC,UAAM,MAAM,MAAM,KAAK,2BAA2B,KAAK,IAAI;AAC3D,UAAM,gBAAY,oCAAgB,KAAK,KAAK,YAAY;AACxD,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,OAAO,6BAA6B,KAAK,KAAK,YAAY;AAAA,IACtE;AACA,QAAI,UAAU,SAAS,QAAQ;AAC7B,YAAM,IAAI,OAAO,iBAAiB,+BAA+B;AAAA,IACnE;AAEA,QAAI;AACJ,QAAI;AACF,iBAAW,MAAM,IAAI,oBAAoB,SAAS;AAAA,IACpD,SAAS,QAAP;AACA,YAAM,OAAO,iBAAiB,KAAK,QAAQ,2BAA2B,KAAK,KAAK,cAAc;AAAA,IAChG;AAEA,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,OAAO,iBAAiB,aAAa,KAAK,KAAK,wBAAwB;AAAA,IACnF;AAEA,QAAI;AACF,YAAM,IAAI,OAAO,gBAAgB,EAAE,IAAI,SAAS,GAAG,CAAC;AAAA,IACtD,SAAS,QAAP;AACA,YAAM,OAAO,iBAAiB,KAAK,QAAQ,8BAA8B,KAAK,KAAK,cAAc;AAAA,IACnG;AAEA,SAAK,OAAO,QAAQ,aAAa,aAAAA,QAAM,KAAK,KAAK,KAAK,YAAY,WAAW;AAC7E;AAAA,EACF;AACF;",
  "names": ["chalk"]
}
